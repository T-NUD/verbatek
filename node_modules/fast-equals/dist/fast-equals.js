(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.fe = {})));
}(this, (function (exports) { 'use strict';

  /**
   * @constant {boolean} HAS_MAP_SUPPORT
   */
  var HAS_MAP_SUPPORT = typeof Map === 'function';

  /**
   * @constant {boolean} HAS_SET_SUPPORT
   */
  var HAS_SET_SUPPORT = typeof Set === 'function';

  /**
   * @constant {boolean} HAS_WEAKSET_SUPPORT
   */
  var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';

  // constants

  var keys = Object.keys;

  /**
   * @function addObjectToCache
   *
   * @description
   * add object to cache if it is indeed an object
   *
   * @param {any} object the object to potentially add to the cache
   * @param {Object|WeakSet} cache the cache to add to
   * @returns {void}
   */
  var addObjectToCache = function addObjectToCache(object, cache) {
    return object && typeof object === 'object' && cache.add(object);
  };

  /**
   * @function hasKey
   *
   * @description
   * does the array of keys include the key passed
   *
   * @param {Array<string>} keys the keys to check in
   * @param {string} key the key to locate
   * @returns {boolean} does the key exist in the keys
   */
  var hasKey = function hasKey(keys, key) {
    for (var index = 0; index < keys.length; index++) {
      if (keys[index] === key) {
        return true;
      }
    }

    return false;
  };

  /**
   * @function sameValueZeroEqual
   *
   * @description
   * are the objects passed strictly equal or both NaN
   *
   * @param {any} objectA the object to compare against
   * @param {any} objectB the object to test
   * @returns {boolean} are the objects equal by the SameValueZero principle
   */
  var sameValueZeroEqual = function sameValueZeroEqual(objectA, objectB) {
    return objectA === objectB || objectA !== objectA && objectB !== objectB;
  };

  /**
   * @function isPlainObject
   *
   * @description
   * is the object a plain object
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object a plain object
   */
  var isPlainObject = function isPlainObject(object) {
    return object.constructor === Object;
  };

  /**
   * @function isPromiseLike
   *
   * @description
   * is the object promise-like (thenable)
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object promise-like
   */
  var isPromiseLike = function isPromiseLike(object) {
    return typeof object.then === 'function';
  };

  /**
   * @function isReactElement
   *
   * @description
   * is the object passed a react element
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object a react element
   */
  var isReactElement = function isReactElement(object) {
    return !!(object.$$typeof && object._store);
  };

  /**
   * @function getNewCache
   *
   * @description
   * get a new cache object to prevent circular references
   *
   * @returns {Object|Weakset} the new cache object
   */
  var getNewCache = function getNewCache() {
    return HAS_WEAKSET_SUPPORT ? new WeakSet() : Object.create({
      _values: [],
      add: function add(value) {
        this._values.push(value);
      },
      has: function has(value) {
        return !!~this._values.indexOf(value);
      }
    });
  };

  /**
   * @function createCircularEqual
   *
   * @description
   * create a custom isEqual handler specific to circular objects
   *
   * @param {funtion} [isEqual] the isEqual comparator to use instead of isDeepEqual
   * @returns {function(any, any): boolean}
   */
  var createCircularEqual = function createCircularEqual(isEqual) {
    return function (isDeepEqual) {
      var comparator = isEqual || isDeepEqual;

      return function (objectA, objectB) {
        var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getNewCache();

        var cacheHasA = cache.has(objectA);
        var cacheHasB = cache.has(objectB);

        if (cacheHasA || cacheHasB) {
          return cacheHasA && cacheHasB;
        }

        addObjectToCache(objectA, cache);
        addObjectToCache(objectB, cache);

        return comparator(objectA, objectB, cache);
      };
    };
  };

  /**
   * @function toPairs
   *
   * @param {Map|Set} iterable the iterable to convert to [key, value] pairs (entries)
   * @returns {{keys: Array<*>, values: Array<*>}} the [key, value] pairs
   */
  var toPairs = function toPairs(iterable) {
    var pairs = { keys: new Array(iterable.size), values: new Array(iterable.size) };

    var index = 0;

    iterable.forEach(function (value, key) {
      pairs.keys[index] = key;
      pairs.values[index++] = value;
    });

    return pairs;
  };

  /**
   * @function areArraysEqual
   *
   * @description
   * are the arrays equal in value
   *
   * @param {Array<any>} arrayA the array to test
   * @param {Array<any>} arrayB the array to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta object to pass through
   * @returns {boolean} are the arrays equal
   */
  var areArraysEqual = function areArraysEqual(arrayA, arrayB, isEqual, meta) {
    if (arrayA.length !== arrayB.length) {
      return false;
    }

    for (var index = 0; index < arrayA.length; index++) {
      if (!isEqual(arrayA[index], arrayB[index], meta)) {
        return false;
      }
    }

    return true;
  };

  var createAreIterablesEqual = function createAreIterablesEqual(shouldCompareKeys) {
    /**
     * @function areIterablesEqual
     *
     * @description
     * determine if the iterables are equivalent in value
     *
     * @param {Array<Array<any>>} pairsA the pairs to test
     * @param {Array<Array<any>>} pairsB the pairs to test against
     * @param {function} isEqual the comparator to determine equality
     * @param {any} meta the cache possibly being used
     * @returns {boolean} are the objects equal in value
     */
    var areIterablesEqual = shouldCompareKeys ? function (pairsA, pairsB, isEqual, meta) {
      return isEqual(pairsA.keys, pairsB.keys) && isEqual(pairsA.values, pairsB.values, meta);
    } : function (pairsA, pairsB, isEqual, meta) {
      return isEqual(pairsA.values, pairsB.values, meta);
    };

    return function (iterableA, iterableB, isEqual, meta) {
      return iterableA.size === iterableB.size && areIterablesEqual(toPairs(iterableA), toPairs(iterableB), isEqual, meta);
    };
  };

  /**
   * @function areArraysEqual
   *
   * @description
   * are the objects equal in value
   *
   * @param {Array<any>} objectA the object to test
   * @param {Array<any>} objectB the object to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta object to pass through
   * @returns {boolean} are the objects equal
   */
  var areObjectsEqual = function areObjectsEqual(objectA, objectB, isEqual, meta) {
    var keysA = keys(objectA);
    var keysB = keys(objectB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    var key = void 0;

    for (var index = 0; index < keysA.length; index++) {
      key = keysA[index];

      if (!hasKey(keysB, key)) {
        return false;
      }

      // if a react element, ignore the "_owner" key because its not necessary for equality comparisons
      if (key === '_owner' && isReactElement(objectA) && isReactElement(objectB)) {
        continue;
      }

      if (!isEqual(objectA[key], objectB[key], meta)) {
        return false;
      }
    }

    return true;
  };

  /**
   * @function areRegExpsEqual
   *
   * @description
   * are the regExps equal in value
   *
   * @param {RegExp} regExpA the regExp to test
   * @param {RegExp} regExpB the regExp to test agains
   * @returns {boolean} are the regExps equal
   */
  var areRegExpsEqual = function areRegExpsEqual(regExpA, regExpB) {
    return regExpA.source === regExpB.source && regExpA.global === regExpB.global && regExpA.ignoreCase === regExpB.ignoreCase && regExpA.multiline === regExpB.multiline && regExpA.unicode === regExpB.unicode && regExpA.sticky === regExpB.sticky && regExpA.lastIndex === regExpB.lastIndex;
  };

  // constants

  var isArray = Array.isArray;

  var areMapsEqual = createAreIterablesEqual(true);
  var areSetsEqual = createAreIterablesEqual(false);

  var createComparator = function createComparator(createIsEqual) {
    // eslint-disable-next-line no-use-before-define
    var isEqual = typeof createIsEqual === 'function' ? createIsEqual(comparator) : comparator;

    /**
     * @function comparator
     *
     * @description
     * compare the value of the two objects and return true if they are equivalent in values
     *
     * @param {any} objectA the object to test against
     * @param {any} objectB the object to test
     * @param {any} [meta] an optional meta object that is passed through to all equality test calls
     * @returns {boolean} are objectA and objectB equivalent in value
     */
    function comparator(objectA, objectB, meta) {
      if (sameValueZeroEqual(objectA, objectB)) {
        return true;
      }

      var typeOfA = typeof objectA;

      if (typeOfA !== typeof objectB || typeOfA !== 'object' || !objectA || !objectB) {
        return false;
      }

      if (isPlainObject(objectA) && isPlainObject(objectB)) {
        return areObjectsEqual(objectA, objectB, isEqual, meta);
      }

      var arrayA = isArray(objectA);
      var arrayB = isArray(objectB);

      if (arrayA || arrayB) {
        return arrayA === arrayB && areArraysEqual(objectA, objectB, isEqual, meta);
      }

      var dateA = objectA instanceof Date;
      var dateB = objectB instanceof Date;

      if (dateA || dateB) {
        return dateA === dateB && sameValueZeroEqual(objectA.getTime(), objectB.getTime());
      }

      var regexpA = objectA instanceof RegExp;
      var regexpB = objectB instanceof RegExp;

      if (regexpA || regexpB) {
        return regexpA === regexpB && areRegExpsEqual(objectA, objectB);
      }

      if (isPromiseLike(objectA) || isPromiseLike(objectB)) {
        return objectA === objectB;
      }

      if (HAS_MAP_SUPPORT) {
        var mapA = objectA instanceof Map;
        var mapB = objectB instanceof Map;

        if (mapA || mapB) {
          return mapA === mapB && areMapsEqual(objectA, objectB, comparator, meta);
        }
      }

      if (HAS_SET_SUPPORT) {
        var setA = objectA instanceof Set;
        var setB = objectB instanceof Set;

        if (setA || setB) {
          return setA === setB && areSetsEqual(objectA, objectB, comparator, meta);
        }
      }

      return areObjectsEqual(objectA, objectB, isEqual, meta);
    }

    return comparator;
  };

  // comparator

  var circularDeepEqual = createComparator(createCircularEqual());
  var circularShallowEqual = createComparator(createCircularEqual(sameValueZeroEqual));
  var deepEqual = createComparator();
  var shallowEqual = createComparator(function () {
    return sameValueZeroEqual;
  });

  var index = {
    circularDeep: circularDeepEqual,
    circularShallow: circularShallowEqual,
    createCustom: createComparator,
    deep: deepEqual,
    sameValueZero: sameValueZeroEqual,
    shallow: shallowEqual
  };

  exports.createCustomEqual = createComparator;
  exports.sameValueZeroEqual = sameValueZeroEqual;
  exports.circularDeepEqual = circularDeepEqual;
  exports.circularShallowEqual = circularShallowEqual;
  exports.deepEqual = deepEqual;
  exports.shallowEqual = shallowEqual;
  exports.default = index;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=fast-equals.js.map

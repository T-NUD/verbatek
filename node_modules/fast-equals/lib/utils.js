'use strict';

exports.__esModule = true;
exports.areRegExpsEqual = exports.areObjectsEqual = exports.createAreIterablesEqual = exports.areArraysEqual = exports.toPairs = exports.createCircularEqual = exports.getNewCache = exports.isReactElement = exports.isPromiseLike = exports.isPlainObject = exports.sameValueZeroEqual = exports.hasKey = exports.addObjectToCache = undefined;

var _constants = require('./constants');

var keys = Object.keys;

/**
 * @function addObjectToCache
 *
 * @description
 * add object to cache if it is indeed an object
 *
 * @param {any} object the object to potentially add to the cache
 * @param {Object|WeakSet} cache the cache to add to
 * @returns {void}
 */
// constants
var addObjectToCache = exports.addObjectToCache = function addObjectToCache(object, cache) {
  return object && typeof object === 'object' && cache.add(object);
};

/**
 * @function hasKey
 *
 * @description
 * does the array of keys include the key passed
 *
 * @param {Array<string>} keys the keys to check in
 * @param {string} key the key to locate
 * @returns {boolean} does the key exist in the keys
 */
var hasKey = exports.hasKey = function hasKey(keys, key) {
  for (var index = 0; index < keys.length; index++) {
    if (keys[index] === key) {
      return true;
    }
  }

  return false;
};

/**
 * @function sameValueZeroEqual
 *
 * @description
 * are the objects passed strictly equal or both NaN
 *
 * @param {any} objectA the object to compare against
 * @param {any} objectB the object to test
 * @returns {boolean} are the objects equal by the SameValueZero principle
 */
var sameValueZeroEqual = exports.sameValueZeroEqual = function sameValueZeroEqual(objectA, objectB) {
  return objectA === objectB || objectA !== objectA && objectB !== objectB;
};

/**
 * @function isPlainObject
 *
 * @description
 * is the object a plain object
 *
 * @param {any} object the object to test
 * @returns {boolean} is the object a plain object
 */
var isPlainObject = exports.isPlainObject = function isPlainObject(object) {
  return object.constructor === Object;
};

/**
 * @function isPromiseLike
 *
 * @description
 * is the object promise-like (thenable)
 *
 * @param {any} object the object to test
 * @returns {boolean} is the object promise-like
 */
var isPromiseLike = exports.isPromiseLike = function isPromiseLike(object) {
  return typeof object.then === 'function';
};

/**
 * @function isReactElement
 *
 * @description
 * is the object passed a react element
 *
 * @param {any} object the object to test
 * @returns {boolean} is the object a react element
 */
var isReactElement = exports.isReactElement = function isReactElement(object) {
  return !!(object.$$typeof && object._store);
};

/**
 * @function getNewCache
 *
 * @description
 * get a new cache object to prevent circular references
 *
 * @returns {Object|Weakset} the new cache object
 */
var getNewCache = exports.getNewCache = function getNewCache() {
  return _constants.HAS_WEAKSET_SUPPORT ? new WeakSet() : Object.create({
    _values: [],
    add: function add(value) {
      this._values.push(value);
    },
    has: function has(value) {
      return !!~this._values.indexOf(value);
    }
  });
};

/**
 * @function createCircularEqual
 *
 * @description
 * create a custom isEqual handler specific to circular objects
 *
 * @param {funtion} [isEqual] the isEqual comparator to use instead of isDeepEqual
 * @returns {function(any, any): boolean}
 */
var createCircularEqual = exports.createCircularEqual = function createCircularEqual(isEqual) {
  return function (isDeepEqual) {
    var comparator = isEqual || isDeepEqual;

    return function (objectA, objectB) {
      var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getNewCache();

      var cacheHasA = cache.has(objectA);
      var cacheHasB = cache.has(objectB);

      if (cacheHasA || cacheHasB) {
        return cacheHasA && cacheHasB;
      }

      addObjectToCache(objectA, cache);
      addObjectToCache(objectB, cache);

      return comparator(objectA, objectB, cache);
    };
  };
};

/**
 * @function toPairs
 *
 * @param {Map|Set} iterable the iterable to convert to [key, value] pairs (entries)
 * @returns {{keys: Array<*>, values: Array<*>}} the [key, value] pairs
 */
var toPairs = exports.toPairs = function toPairs(iterable) {
  var pairs = { keys: new Array(iterable.size), values: new Array(iterable.size) };

  var index = 0;

  iterable.forEach(function (value, key) {
    pairs.keys[index] = key;
    pairs.values[index++] = value;
  });

  return pairs;
};

/**
 * @function areArraysEqual
 *
 * @description
 * are the arrays equal in value
 *
 * @param {Array<any>} arrayA the array to test
 * @param {Array<any>} arrayB the array to test against
 * @param {function} isEqual the comparator to determine equality
 * @param {any} meta the meta object to pass through
 * @returns {boolean} are the arrays equal
 */
var areArraysEqual = exports.areArraysEqual = function areArraysEqual(arrayA, arrayB, isEqual, meta) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }

  for (var index = 0; index < arrayA.length; index++) {
    if (!isEqual(arrayA[index], arrayB[index], meta)) {
      return false;
    }
  }

  return true;
};

var createAreIterablesEqual = exports.createAreIterablesEqual = function createAreIterablesEqual(shouldCompareKeys) {
  /**
   * @function areIterablesEqual
   *
   * @description
   * determine if the iterables are equivalent in value
   *
   * @param {Array<Array<any>>} pairsA the pairs to test
   * @param {Array<Array<any>>} pairsB the pairs to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the cache possibly being used
   * @returns {boolean} are the objects equal in value
   */
  var areIterablesEqual = shouldCompareKeys ? function (pairsA, pairsB, isEqual, meta) {
    return isEqual(pairsA.keys, pairsB.keys) && isEqual(pairsA.values, pairsB.values, meta);
  } : function (pairsA, pairsB, isEqual, meta) {
    return isEqual(pairsA.values, pairsB.values, meta);
  };

  return function (iterableA, iterableB, isEqual, meta) {
    return iterableA.size === iterableB.size && areIterablesEqual(toPairs(iterableA), toPairs(iterableB), isEqual, meta);
  };
};

/**
 * @function areArraysEqual
 *
 * @description
 * are the objects equal in value
 *
 * @param {Array<any>} objectA the object to test
 * @param {Array<any>} objectB the object to test against
 * @param {function} isEqual the comparator to determine equality
 * @param {any} meta the meta object to pass through
 * @returns {boolean} are the objects equal
 */
var areObjectsEqual = exports.areObjectsEqual = function areObjectsEqual(objectA, objectB, isEqual, meta) {
  var keysA = keys(objectA);
  var keysB = keys(objectB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var key = void 0;

  for (var index = 0; index < keysA.length; index++) {
    key = keysA[index];

    if (!hasKey(keysB, key)) {
      return false;
    }

    // if a react element, ignore the "_owner" key because its not necessary for equality comparisons
    if (key === '_owner' && isReactElement(objectA) && isReactElement(objectB)) {
      continue;
    }

    if (!isEqual(objectA[key], objectB[key], meta)) {
      return false;
    }
  }

  return true;
};

/**
 * @function areRegExpsEqual
 *
 * @description
 * are the regExps equal in value
 *
 * @param {RegExp} regExpA the regExp to test
 * @param {RegExp} regExpB the regExp to test agains
 * @returns {boolean} are the regExps equal
 */
var areRegExpsEqual = exports.areRegExpsEqual = function areRegExpsEqual(regExpA, regExpB) {
  return regExpA.source === regExpB.source && regExpA.global === regExpB.global && regExpA.ignoreCase === regExpB.ignoreCase && regExpA.multiline === regExpB.multiline && regExpA.unicode === regExpB.unicode && regExpA.sticky === regExpB.sticky && regExpA.lastIndex === regExpB.lastIndex;
};
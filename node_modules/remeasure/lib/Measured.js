'use strict';

exports.__esModule = true;
exports.createSetResizeObserver = exports.createSetRenderMethod = exports.createSetRef = exports.createGetPassedValues = exports.createDisconnectObserver = exports.createConnectObserver = exports.createComponentWillUnmount = exports.createComponentDidUpdate = exports.createSetValues = exports.createComponentWillReceiveProps = exports.createComponentDidMount = exports.createComponentWillMount = exports.getInitialState = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _debounce = require('debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _fastEquals = require('fast-equals');

var _microMemoize = require('micro-memoize');

var _microMemoize2 = _interopRequireDefault(_microMemoize);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _resizeObserverPolyfill = require('resize-observer-polyfill');

var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

var _constants = require('./constants');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // external dependencies


// constants


// utils


/**
 * @private
 *
 * @function getInitialState
 *
 * @description
 * get the initial state of the component instance
 *
 * @returns {Object} the initial state
 */
var getInitialState = exports.getInitialState = function getInitialState() {
  return _constants.KEY_NAMES.reduce(function (state, key) {
    state[key] = null;

    return state;
  }, {});
};

var createComponentWillMount = exports.createComponentWillMount = function createComponentWillMount(instance) {
  /**
   * @private
   *
   * @function componentWillMount
   *
   * @description
   * prior to mount, set the keys to watch for and the render method
   */
  return function () {
    instance.keys = (0, _utils.getStateKeys)(instance.props);

    instance.setRenderMethod(instance.props);
  };
};

var createComponentDidMount = exports.createComponentDidMount = function createComponentDidMount(instance) {
  /**
   * @private
   *
   * @function componentDidMount
   *
   * @description
   * on mount, get the element and set it's resize observer
   */
  return function () {
    instance._isMounted = true;

    instance.element = (0, _reactDom.findDOMNode)(instance);

    instance.setResizeObserver();
  };
};

var createComponentWillReceiveProps = exports.createComponentWillReceiveProps = function createComponentWillReceiveProps(instance) {
  /**
   * @private
   *
   * @function componentWillReceiveProps
   *
   * @description
   * when the component receives new props, set the render method for future renders
   *
   * @param {Object} nextProps the next render's props
   */
  return function (nextProps) {
    instance.setRenderMethod(nextProps);
  };
};

var createSetValues = exports.createSetValues = function createSetValues(instance, isDebounce) {
  var debounce = instance.props.debounce;

  /**
   * @private
   *
   * @function delayedMethod
   *
   * @description
   * on a delay (either requestAnimationFrame or debounce), determine the calculated measurements and assign
   * them to state if changed
   */

  var delayedMethod = function delayedMethod() {
    var clientRect = instance.element ? instance.element.getBoundingClientRect() : {};

    var newValues = _constants.KEYS.reduce(function (values, key) {
      values[key.key] = ~instance.keys.indexOf(key) ? instance.element ? (0, _utils.getNaturalDimensionValue)(key.source === _constants.SOURCES.CLIENT_RECT ? clientRect : instance.element, key.key) : 0 : null;

      return values;
    }, {});

    if (!(0, _fastEquals.deepEqual)(instance.state, newValues) && instance._isMounted) {
      instance.setState(function () {
        return newValues;
      });
    }
  };

  return isDebounce && typeof debounce === 'number' ? (0, _debounce2.default)(delayedMethod, debounce) : function () {
    (0, _raf2.default)(delayedMethod);
  };
};

var createComponentDidUpdate = exports.createComponentDidUpdate = function createComponentDidUpdate(instance) {
  /**
   * @private
   *
   * @function componentDidUpdate
   *
   * @description
   * on update, assign the new properties if they have changed
   *   * element
   *   * debounce (assign new debounced render method)
   *   * keys
   *
   * @param {number} [previousDebounce] the previous props' debounce value
   */
  return function (_ref) {
    var previousDebounce = _ref.debounce;
    var debounce = instance.props.debounce;


    var element = (0, _reactDom.findDOMNode)(instance);

    var hasElementChanged = element !== instance.element;
    var hasDebounceChanged = debounce !== previousDebounce;
    var shouldSetResizeObserver = hasElementChanged || hasDebounceChanged;

    if (hasElementChanged) {
      instance.element = element;
    }

    if (hasDebounceChanged) {
      instance.setValuesViaDebounce = createSetValues(instance, true);
    }

    if (shouldSetResizeObserver) {
      instance.setResizeObserver();
    }

    var newKeys = (0, _utils.getStateKeys)(instance.props);

    if (shouldSetResizeObserver || !(0, _fastEquals.deepEqual)(instance.keys, newKeys)) {
      instance.keys = newKeys;

      instance.resizeMethod();
    }
  };
};

var createComponentWillUnmount = exports.createComponentWillUnmount = function createComponentWillUnmount(instance) {
  /**
   * @private
   *
   * @function componentWillUnmount
   *
   * @description
   * prior to unmount, disconnect the resize observer and reset the instance properties
   */
  return function () {
    instance._isMounted = false;

    instance.disconnectObserver();

    instance.element = null;
    instance.keys = [];
    instance.resizeMethod = null;
  };
};

var createConnectObserver = exports.createConnectObserver = function createConnectObserver(instance) {
  /**
   * @private
   *
   * @function connectObserver
   *
   * @description
   * if render on resize is requested, assign a resize observer to the element with the correct resize method
   */
  return function () {
    var renderOnResize = instance.props.renderOnResize;


    if (renderOnResize) {
      if (!_constants.IS_PRODUCTION && (0, _utils.isElementVoidTag)(instance.element)) {
        /* eslint-disable no-console */
        console.warn('WARNING: You are attempting to listen to resizes on a void element, which is not supported. You should wrap this element in an element that supports children, such as a <div>, to ensure correct behavior.');
        /* eslint-enable */
      }

      instance.resizeObserver = new _resizeObserverPolyfill2.default(instance.resizeMethod);

      instance.resizeObserver.observe(instance.element);
    }
  };
};

var createDisconnectObserver = exports.createDisconnectObserver = function createDisconnectObserver(instance) {
  /**
   * @private
   *
   * @function disconnectObserver
   *
   * @description
   * if a resize observer exists, disconnect it from the element
   */
  return function () {
    if (instance.resizeObserver) {
      instance.resizeObserver.disconnect(instance.element);

      instance.resizeObserver = null;
    }
  };
};

var createGetPassedValues = exports.createGetPassedValues = function createGetPassedValues(instance) {
  /**
   * @private
   *
   * @function getPassedValues
   *
   * @description
   * get the passed values as an object, namespaced if requested
   *
   * @param {Object} state the current state values
   * @param {string} [namespace] the possible namespace to assign the values to
   * @returns {Object} the values to pass
   */
  return (0, _microMemoize2.default)(function (state, namespace) {
    var _ref3;

    var populatedState = instance.keys.reduce(function (values, _ref2) {
      var key = _ref2.key;

      values[key] = state[key] || 0;

      return values;
    }, {});

    return namespace ? (_ref3 = {}, _ref3[namespace] = populatedState, _ref3) : populatedState;
  });
};

var createSetRef = exports.createSetRef = function createSetRef(instance, ref) {
  /**
   * @private
   *
   * @function setRef
   *
   * @description
   * set the DOM node to the ref passed
   *
   * @param {HTMLElement|ReactComponent} element the element to find the DOM node of
   */
  return function (element) {
    instance[ref] = (0, _reactDom.findDOMNode)(element);
  };
};

var createSetRenderMethod = exports.createSetRenderMethod = function createSetRenderMethod(instance) {
  /**
   * @private
   *
   * @function setRenderMethod
   *
   * @description
   * set the render method based on the possible props passed
   *
   * @param {function} [children] the child render function
   * @param {function} [component] the component prop function
   * @param {function} [render] the render prop function
   */
  return function (_ref4) {
    var children = _ref4.children,
        component = _ref4.component,
        render = _ref4.render;

    var RenderComponent = children || component || render || null;

    if (!_constants.IS_PRODUCTION && typeof RenderComponent !== 'function') {
      /* eslint-disable no-console */
      console.error('ERROR: You must provide a render function, or either a "render" or "component" prop that passes a functional component.');
      /* eslint-enable */
    }

    if (RenderComponent !== instance.RenderComponent) {
      instance.RenderComponent = RenderComponent;
    }
  };
};

var createSetResizeObserver = exports.createSetResizeObserver = function createSetResizeObserver(instance) {
  /**
   * @private
   *
   * @function setResizeObserver
   *
   * @description
   * set the resize observer on the instance, based on the existence of a currrent resizeObserver and the new element
   */
  return function () {
    var debounce = instance.props.debounce;


    var resizeMethod = typeof debounce === 'number' ? instance.setValuesViaDebounce : instance.setValuesViaRaf;

    if (resizeMethod !== instance.resizeMethod) {
      instance.resizeMethod = resizeMethod;

      resizeMethod();
    }

    if (instance.resizeObserver) {
      instance.disconnectObserver();
    }

    if (instance.element) {
      instance.connectObserver();
    }
  };
};

var Measured = function (_Component) {
  _inherits(Measured, _Component);

  function Measured() {
    var _temp, _this, _ret;

    _classCallCheck(this, Measured);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = getInitialState(), _this.componentWillMount = createComponentWillMount(_this), _this.componentDidMount = createComponentDidMount(_this), _this.componentWillReceiveProps = createComponentWillReceiveProps(_this), _this.componentDidUpdate = createComponentDidUpdate(_this), _this.componentWillUnmount = createComponentWillUnmount(_this), _this._isMounted = false, _this.element = null, _this.keys = [], _this.RenderComponent = null, _this.resizeMethod = null, _this.resizeObserver = null, _this.connectObserver = createConnectObserver(_this), _this.disconnectObserver = createDisconnectObserver(_this), _this.getPassedValues = createGetPassedValues(_this), _this.setElementRef = createSetRef(_this, 'element'), _this.setRenderMethod = createSetRenderMethod(_this), _this.setResizeObserver = createSetResizeObserver(_this), _this.setValuesViaDebounce = createSetValues(_this, true), _this.setValuesViaRaf = createSetValues(_this, false), _temp), _possibleConstructorReturn(_this, _ret);
  }

  // state


  // lifecycle methods


  // instance values


  // instance methods


  Measured.prototype.render = function render() {
    var _props = this.props,
        childrenIgnored = _props.children,
        componentIgnored = _props.component,
        debounceIgnored = _props.debounce,
        keysIgnored = _props.keys,
        namespace = _props.namespace,
        renderIgnored = _props.render,
        renderOnResizeIgnored = _props.renderOnResize,
        passThroughProps = _objectWithoutProperties(_props, ['children', 'component', 'debounce', 'keys', 'namespace', 'render', 'renderOnResize']);

    if (!this.RenderComponent) {
      return null;
    }

    var RenderComponent = this.RenderComponent;

    return (
      /* eslint-disable prettier */
      _react2.default.createElement(RenderComponent, _extends({}, passThroughProps, this.getPassedValues(this.state, namespace)))
      /* eslint-enable */

    );
  };

  return Measured;
}(_react.Component);

Measured.displayName = 'Measured';
Measured.propTypes = _extends({
  children: _propTypes2.default.func,
  component: _propTypes2.default.func,
  debounce: _propTypes2.default.number,
  namespace: _propTypes2.default.string,
  render: _propTypes2.default.func,
  renderOnResize: _propTypes2.default.bool.isRequired
}, _constants.KEY_NAMES.reduce(function (keyPropTypes, key) {
  keyPropTypes[key] = _propTypes2.default.bool;

  return keyPropTypes;
}, {}));
Measured.defaultProps = {
  renderOnResize: true
};
exports.default = Measured;
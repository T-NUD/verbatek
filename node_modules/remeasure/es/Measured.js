var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// external dependencies
import debounceMethod from 'debounce';
import { deepEqual } from 'fast-equals';
import memoize from 'micro-memoize';
import PropTypes from 'prop-types';
import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import raf from 'raf';
import ResizeObserver from 'resize-observer-polyfill';

// constants
import { IS_PRODUCTION, KEY_NAMES, KEYS, SOURCES } from './constants';

// utils
import { getNaturalDimensionValue, getStateKeys, isElementVoidTag } from './utils';

/**
 * @private
 *
 * @function getInitialState
 *
 * @description
 * get the initial state of the component instance
 *
 * @returns {Object} the initial state
 */
export var getInitialState = function getInitialState() {
  return KEY_NAMES.reduce(function (state, key) {
    state[key] = null;

    return state;
  }, {});
};

export var createComponentWillMount = function createComponentWillMount(instance) {
  /**
   * @private
   *
   * @function componentWillMount
   *
   * @description
   * prior to mount, set the keys to watch for and the render method
   */
  return function () {
    instance.keys = getStateKeys(instance.props);

    instance.setRenderMethod(instance.props);
  };
};

export var createComponentDidMount = function createComponentDidMount(instance) {
  /**
   * @private
   *
   * @function componentDidMount
   *
   * @description
   * on mount, get the element and set it's resize observer
   */
  return function () {
    instance._isMounted = true;

    instance.element = findDOMNode(instance);

    instance.setResizeObserver();
  };
};

export var createComponentWillReceiveProps = function createComponentWillReceiveProps(instance) {
  /**
   * @private
   *
   * @function componentWillReceiveProps
   *
   * @description
   * when the component receives new props, set the render method for future renders
   *
   * @param {Object} nextProps the next render's props
   */
  return function (nextProps) {
    instance.setRenderMethod(nextProps);
  };
};

export var createSetValues = function createSetValues(instance, isDebounce) {
  var debounce = instance.props.debounce;

  /**
   * @private
   *
   * @function delayedMethod
   *
   * @description
   * on a delay (either requestAnimationFrame or debounce), determine the calculated measurements and assign
   * them to state if changed
   */

  var delayedMethod = function delayedMethod() {
    var clientRect = instance.element ? instance.element.getBoundingClientRect() : {};

    var newValues = KEYS.reduce(function (values, key) {
      values[key.key] = ~instance.keys.indexOf(key) ? instance.element ? getNaturalDimensionValue(key.source === SOURCES.CLIENT_RECT ? clientRect : instance.element, key.key) : 0 : null;

      return values;
    }, {});

    if (!deepEqual(instance.state, newValues) && instance._isMounted) {
      instance.setState(function () {
        return newValues;
      });
    }
  };

  return isDebounce && typeof debounce === 'number' ? debounceMethod(delayedMethod, debounce) : function () {
    raf(delayedMethod);
  };
};

export var createComponentDidUpdate = function createComponentDidUpdate(instance) {
  /**
   * @private
   *
   * @function componentDidUpdate
   *
   * @description
   * on update, assign the new properties if they have changed
   *   * element
   *   * debounce (assign new debounced render method)
   *   * keys
   *
   * @param {number} [previousDebounce] the previous props' debounce value
   */
  return function (_ref) {
    var previousDebounce = _ref.debounce;
    var debounce = instance.props.debounce;


    var element = findDOMNode(instance);

    var hasElementChanged = element !== instance.element;
    var hasDebounceChanged = debounce !== previousDebounce;
    var shouldSetResizeObserver = hasElementChanged || hasDebounceChanged;

    if (hasElementChanged) {
      instance.element = element;
    }

    if (hasDebounceChanged) {
      instance.setValuesViaDebounce = createSetValues(instance, true);
    }

    if (shouldSetResizeObserver) {
      instance.setResizeObserver();
    }

    var newKeys = getStateKeys(instance.props);

    if (shouldSetResizeObserver || !deepEqual(instance.keys, newKeys)) {
      instance.keys = newKeys;

      instance.resizeMethod();
    }
  };
};

export var createComponentWillUnmount = function createComponentWillUnmount(instance) {
  /**
   * @private
   *
   * @function componentWillUnmount
   *
   * @description
   * prior to unmount, disconnect the resize observer and reset the instance properties
   */
  return function () {
    instance._isMounted = false;

    instance.disconnectObserver();

    instance.element = null;
    instance.keys = [];
    instance.resizeMethod = null;
  };
};

export var createConnectObserver = function createConnectObserver(instance) {
  /**
   * @private
   *
   * @function connectObserver
   *
   * @description
   * if render on resize is requested, assign a resize observer to the element with the correct resize method
   */
  return function () {
    var renderOnResize = instance.props.renderOnResize;


    if (renderOnResize) {
      if (!IS_PRODUCTION && isElementVoidTag(instance.element)) {
        /* eslint-disable no-console */
        console.warn('WARNING: You are attempting to listen to resizes on a void element, which is not supported. You should wrap this element in an element that supports children, such as a <div>, to ensure correct behavior.');
        /* eslint-enable */
      }

      instance.resizeObserver = new ResizeObserver(instance.resizeMethod);

      instance.resizeObserver.observe(instance.element);
    }
  };
};

export var createDisconnectObserver = function createDisconnectObserver(instance) {
  /**
   * @private
   *
   * @function disconnectObserver
   *
   * @description
   * if a resize observer exists, disconnect it from the element
   */
  return function () {
    if (instance.resizeObserver) {
      instance.resizeObserver.disconnect(instance.element);

      instance.resizeObserver = null;
    }
  };
};

export var createGetPassedValues = function createGetPassedValues(instance) {
  /**
   * @private
   *
   * @function getPassedValues
   *
   * @description
   * get the passed values as an object, namespaced if requested
   *
   * @param {Object} state the current state values
   * @param {string} [namespace] the possible namespace to assign the values to
   * @returns {Object} the values to pass
   */
  return memoize(function (state, namespace) {
    var _ref3;

    var populatedState = instance.keys.reduce(function (values, _ref2) {
      var key = _ref2.key;

      values[key] = state[key] || 0;

      return values;
    }, {});

    return namespace ? (_ref3 = {}, _ref3[namespace] = populatedState, _ref3) : populatedState;
  });
};

export var createSetRef = function createSetRef(instance, ref) {
  /**
   * @private
   *
   * @function setRef
   *
   * @description
   * set the DOM node to the ref passed
   *
   * @param {HTMLElement|ReactComponent} element the element to find the DOM node of
   */
  return function (element) {
    instance[ref] = findDOMNode(element);
  };
};

export var createSetRenderMethod = function createSetRenderMethod(instance) {
  /**
   * @private
   *
   * @function setRenderMethod
   *
   * @description
   * set the render method based on the possible props passed
   *
   * @param {function} [children] the child render function
   * @param {function} [component] the component prop function
   * @param {function} [render] the render prop function
   */
  return function (_ref4) {
    var children = _ref4.children,
        component = _ref4.component,
        render = _ref4.render;

    var RenderComponent = children || component || render || null;

    if (!IS_PRODUCTION && typeof RenderComponent !== 'function') {
      /* eslint-disable no-console */
      console.error('ERROR: You must provide a render function, or either a "render" or "component" prop that passes a functional component.');
      /* eslint-enable */
    }

    if (RenderComponent !== instance.RenderComponent) {
      instance.RenderComponent = RenderComponent;
    }
  };
};

export var createSetResizeObserver = function createSetResizeObserver(instance) {
  /**
   * @private
   *
   * @function setResizeObserver
   *
   * @description
   * set the resize observer on the instance, based on the existence of a currrent resizeObserver and the new element
   */
  return function () {
    var debounce = instance.props.debounce;


    var resizeMethod = typeof debounce === 'number' ? instance.setValuesViaDebounce : instance.setValuesViaRaf;

    if (resizeMethod !== instance.resizeMethod) {
      instance.resizeMethod = resizeMethod;

      resizeMethod();
    }

    if (instance.resizeObserver) {
      instance.disconnectObserver();
    }

    if (instance.element) {
      instance.connectObserver();
    }
  };
};

var Measured = function (_Component) {
  _inherits(Measured, _Component);

  function Measured() {
    var _temp, _this, _ret;

    _classCallCheck(this, Measured);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = getInitialState(), _this.componentWillMount = createComponentWillMount(_this), _this.componentDidMount = createComponentDidMount(_this), _this.componentWillReceiveProps = createComponentWillReceiveProps(_this), _this.componentDidUpdate = createComponentDidUpdate(_this), _this.componentWillUnmount = createComponentWillUnmount(_this), _this._isMounted = false, _this.element = null, _this.keys = [], _this.RenderComponent = null, _this.resizeMethod = null, _this.resizeObserver = null, _this.connectObserver = createConnectObserver(_this), _this.disconnectObserver = createDisconnectObserver(_this), _this.getPassedValues = createGetPassedValues(_this), _this.setElementRef = createSetRef(_this, 'element'), _this.setRenderMethod = createSetRenderMethod(_this), _this.setResizeObserver = createSetResizeObserver(_this), _this.setValuesViaDebounce = createSetValues(_this, true), _this.setValuesViaRaf = createSetValues(_this, false), _temp), _possibleConstructorReturn(_this, _ret);
  }

  // state


  // lifecycle methods


  // instance values


  // instance methods


  Measured.prototype.render = function render() {
    var _props = this.props,
        childrenIgnored = _props.children,
        componentIgnored = _props.component,
        debounceIgnored = _props.debounce,
        keysIgnored = _props.keys,
        namespace = _props.namespace,
        renderIgnored = _props.render,
        renderOnResizeIgnored = _props.renderOnResize,
        passThroughProps = _objectWithoutProperties(_props, ['children', 'component', 'debounce', 'keys', 'namespace', 'render', 'renderOnResize']);

    if (!this.RenderComponent) {
      return null;
    }

    var RenderComponent = this.RenderComponent;

    return (
      /* eslint-disable prettier */
      React.createElement(RenderComponent, _extends({}, passThroughProps, this.getPassedValues(this.state, namespace)))
      /* eslint-enable */

    );
  };

  return Measured;
}(Component);

Measured.displayName = 'Measured';
Measured.propTypes = _extends({
  children: PropTypes.func,
  component: PropTypes.func,
  debounce: PropTypes.number,
  namespace: PropTypes.string,
  render: PropTypes.func,
  renderOnResize: PropTypes.bool.isRequired
}, KEY_NAMES.reduce(function (keyPropTypes, key) {
  keyPropTypes[key] = PropTypes.bool;

  return keyPropTypes;
}, {}));
Measured.defaultProps = {
  renderOnResize: true
};


export default Measured;
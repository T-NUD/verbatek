(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.memoize = {})));
}(this, (function (exports) { 'use strict';

/**
 * @function cloneArray
 *
 * @description
 * clone the array-like object and return the new array
 *
 * @param {Array<any>|Arguments} arrayLike the array-like object to clone
 * @returns {Array<any>} the clone of the array
 */
var cloneArray = function cloneArray(arrayLike) {
  var array = new Array(arrayLike.length);

  for (var index = 0; index < arrayLike.length; index++) {
    array[index] = arrayLike[index];
  }

  return array;
};

// types


var createAreKeysEqual = function createAreKeysEqual(isEqual) {
  /**
   * @function areKeysEqual
   *
   * @description
   * are the keys shallowly equal to one another
   *
   * @param {Array<any>} keys1 the keys array to test against
   * @param {Array<any>} keys2 the keys array to test
   * @returns {boolean} are the keys shallowly equal
   */
  return function (keys1, keys2) {
    if (keys1.length !== keys2.length) {
      return false;
    }

    for (var index = 0; index < keys1.length; index++) {
      if (!isEqual(keys1[index], keys2[index])) {
        return false;
      }
    }

    return true;
  };
};

var createGetKeyIndex = function createGetKeyIndex(isEqual) {
  var areKeysEqual = createAreKeysEqual(isEqual);

  /**
   * @function getKeyIndex
   *
   * @description
   * get the index of the matching key
   *
   * @param {Array<Array<any>>} allKeys the list of all available keys
   * @param {Array<any>} keysToMatch the key to try to match
   *
   * @returns {number} the index of the matching key value, or -1
   */
  return function (allKeys, keysToMatch) {
    for (var index = 0; index < allKeys.length; index++) {
      if (areKeysEqual(allKeys[index], keysToMatch)) {
        return index;
      }
    }

    return -1;
  };
};

var createGetTransformedKey = function createGetTransformedKey(transformKey) {
  /**
   * @function getTransformedKey
   *
   * @description
   * get the transformed key based on the args passed
   *
   * @param {Array<*>} args the args to transform into a key
   * @returns {Array<*>} the transformed key
   */
  return function (args) {
    var key = transformKey(args);

    return Array.isArray(key) ? key : [key];
  };
};

/**
 * @function isSameValueZero
 *
 * @description
 * are the objects equal based on SameValueZero
 *
 * @param {any} object1 the first object to compare
 * @param {any} object2 the second object to compare
 * @returns {boolean} are the two objects equal
 */
var isSameValueZero = function isSameValueZero(object1, object2) {
  return object1 === object2 || object1 !== object1 && object2 !== object2;
};

/* eslint-disable no-unused-vars */
var onCacheOperation = function onCacheOperation(cacheIgnored, optionsIgnored, memoized) {};
/* eslint-enable */

/**
 * @function orderByLru
 *
 * @description
 * order the array based on a Least-Recently-Used basis
 *
 * @param {Array<any>} array the array to order
 * @param {any} value the value to assign at the beginning of the array
 * @param {number} startingIndex the index of the item to move to the front
 */
var orderByLru = function orderByLru(array, value, startingIndex) {
  var index = startingIndex;

  while (index--) {
    array[index + 1] = array[index];
  }

  array[0] = value;
};

/**
 * @function setPromiseHandler
 *
 * @description
 * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed
 *
 * @param {Cache} cache the cache object
 * @param {Options} options the options for the memoized function
 * @param {function} memoized the memoized function
 */
var setPromiseHandler = function setPromiseHandler(cache, options, memoized) {
  var key = cache.keys[0];

  cache.values[0] = cache.values[0].then(function (value) {
    options.onCacheHit(cache, options, memoized);
    options.onCacheChange(cache, options, memoized);

    return value;
  }).catch(function (error) {
    var keyIndex = createGetKeyIndex(options.isEqual)(cache.keys, key);

    if (~keyIndex) {
      cache.keys.splice(keyIndex, 1);
      cache.values.splice(keyIndex, 1);
    }

    throw error;
  });
};

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * @function memoize
 *
 * @description
 * get the memoized version of the method passed
 *
 * @param {function} fn the method to memoize
 * @param {Object} [options={}] the options to build the memoizer with
 * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with
 * @param {number} [options.maxSize=1] the number of items to store in cache
 * @returns {function} the memoized method
 */


// types
function memoize(fn, options) {
  // if it is a memoized method, don't re-memoize it
  if (fn.isMemoized) {
    return fn;
  }

  var _ref = options || {},
      _ref$isEqual = _ref.isEqual,
      isEqual = _ref$isEqual === undefined ? isSameValueZero : _ref$isEqual,
      _ref$isPromise = _ref.isPromise,
      isPromise = _ref$isPromise === undefined ? false : _ref$isPromise,
      _ref$maxSize = _ref.maxSize,
      maxSize = _ref$maxSize === undefined ? 1 : _ref$maxSize,
      _ref$onCacheAdd = _ref.onCacheAdd,
      onCacheAdd = _ref$onCacheAdd === undefined ? onCacheOperation : _ref$onCacheAdd,
      _ref$onCacheChange = _ref.onCacheChange,
      onCacheChange = _ref$onCacheChange === undefined ? onCacheOperation : _ref$onCacheChange,
      _ref$onCacheHit = _ref.onCacheHit,
      onCacheHit = _ref$onCacheHit === undefined ? onCacheOperation : _ref$onCacheHit,
      transformKey = _ref.transformKey,
      extraOptions = _objectWithoutProperties(_ref, ['isEqual', 'isPromise', 'maxSize', 'onCacheAdd', 'onCacheChange', 'onCacheHit', 'transformKey']);

  var normalizedOptions = Object.assign({}, extraOptions, {
    isEqual: isEqual,
    isPromise: isPromise,
    maxSize: maxSize,
    onCacheAdd: onCacheAdd,
    onCacheChange: onCacheChange,
    onCacheHit: onCacheHit,
    transformKey: transformKey
  });

  var getKeyIndex = createGetKeyIndex(isEqual);
  var getTransformedKey = transformKey ? createGetTransformedKey(transformKey) : null;
  var cache = {
    keys: [],
    values: []
  };

  var keys = cache.keys,
      values = cache.values;

  /**
   * @function memoized
   *
   * @description
   * the memoized version of the method passed
   *
   * @param {...Array<any>} key the arguments passed, which create a unique cache key
   * @returns {any} the value of the method called with the arguments
   */

  function memoized() {
    var args = getTransformedKey ? getTransformedKey(cloneArray(arguments)) : arguments;
    var keyIndex = getKeyIndex(keys, args);

    if (~keyIndex) {
      onCacheHit(cache, normalizedOptions, memoized);

      if (keyIndex) {
        orderByLru(keys, keys[keyIndex], keyIndex);
        orderByLru(values, values[keyIndex], keyIndex);

        onCacheChange(cache, normalizedOptions, memoized);
      }
    } else {
      if (keys.length >= maxSize) {
        keys.pop();
        values.pop();
      }

      orderByLru(keys, getTransformedKey ? args : cloneArray(args), keys.length);
      orderByLru(values, fn.apply(this, arguments), values.length);

      if (isPromise) {
        setPromiseHandler(cache, normalizedOptions, memoized);
      }

      onCacheAdd(cache, normalizedOptions, memoized);
      onCacheChange(cache, normalizedOptions, memoized);
    }

    return values[0];
  }

  Object.defineProperties(memoized, {
    cache: {
      configurable: true,
      get: function get() {
        return cache;
      }
    },
    cacheSnapshot: {
      configurable: true,
      get: function get() {
        return {
          keys: cloneArray(cache.keys),
          values: cloneArray(cache.values)
        };
      }
    },
    isMemoized: {
      configurable: true,
      get: function get() {
        return true;
      }
    },
    options: {
      configurable: true,
      get: function get() {
        return normalizedOptions;
      }
    }
  });

  return memoized;
}

exports.default = memoize;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=micro-memoize.js.map

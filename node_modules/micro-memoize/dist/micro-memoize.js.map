{"version":3,"file":"micro-memoize.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["// @flow\n\n// types\nimport type {Cache, Options} from './types';\n\n/**\n * @function cloneArray\n *\n * @description\n * clone the array-like object and return the new array\n *\n * @param {Array<any>|Arguments} arrayLike the array-like object to clone\n * @returns {Array<any>} the clone of the array\n */\nexport const cloneArray = (arrayLike: Array<any> | Object): Array<any> => {\n  const array: Array<any> = new Array(arrayLike.length);\n\n  for (let index: number = 0; index < arrayLike.length; index++) {\n    array[index] = arrayLike[index];\n  }\n\n  return array;\n};\n\nexport const createAreKeysEqual = (isEqual: Function): Function => {\n  /**\n   * @function areKeysEqual\n   *\n   * @description\n   * are the keys shallowly equal to one another\n   *\n   * @param {Array<any>} keys1 the keys array to test against\n   * @param {Array<any>} keys2 the keys array to test\n   * @returns {boolean} are the keys shallowly equal\n   */\n  return (keys1: Array<any>, keys2: Array<any>): boolean => {\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (let index: number = 0; index < keys1.length; index++) {\n      if (!isEqual(keys1[index], keys2[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\n\nexport const createGetKeyIndex = (isEqual: Function): Function => {\n  const areKeysEqual: Function = createAreKeysEqual(isEqual);\n\n  /**\n   * @function getKeyIndex\n   *\n   * @description\n   * get the index of the matching key\n   *\n   * @param {Array<Array<any>>} allKeys the list of all available keys\n   * @param {Array<any>} keysToMatch the key to try to match\n   *\n   * @returns {number} the index of the matching key value, or -1\n   */\n  return (allKeys: Array<Array<any>>, keysToMatch: Array<any>): number => {\n    for (let index: number = 0; index < allKeys.length; index++) {\n      if (areKeysEqual(allKeys[index], keysToMatch)) {\n        return index;\n      }\n    }\n\n    return -1;\n  };\n};\n\nexport const createGetTransformedKey = (transformKey: Function): Function => {\n  /**\n   * @function getTransformedKey\n   *\n   * @description\n   * get the transformed key based on the args passed\n   *\n   * @param {Array<*>} args the args to transform into a key\n   * @returns {Array<*>} the transformed key\n   */\n  return (args: Object): Array<any> => {\n    const key: any = transformKey(args);\n\n    return Array.isArray(key) ? key : [key];\n  };\n};\n\n/**\n * @function isSameValueZero\n *\n * @description\n * are the objects equal based on SameValueZero\n *\n * @param {any} object1 the first object to compare\n * @param {any} object2 the second object to compare\n * @returns {boolean} are the two objects equal\n */\nexport const isSameValueZero = (object1: any, object2: any): boolean => {\n  return object1 === object2 || (object1 !== object1 && object2 !== object2);\n};\n\n/* eslint-disable no-unused-vars */\nexport const onCacheOperation = (cacheIgnored: Cache, optionsIgnored: Options, memoized: Function): void => {};\n/* eslint-enable */\n\n/**\n * @function orderByLru\n *\n * @description\n * order the array based on a Least-Recently-Used basis\n *\n * @param {Array<any>} array the array to order\n * @param {any} value the value to assign at the beginning of the array\n * @param {number} startingIndex the index of the item to move to the front\n */\nexport const orderByLru = (array: Array<any>, value: any, startingIndex: number) => {\n  let index: number = startingIndex;\n\n  while (index--) {\n    array[index + 1] = array[index];\n  }\n\n  array[0] = value;\n};\n\n/**\n * @function setPromiseHandler\n *\n * @description\n * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed\n *\n * @param {Cache} cache the cache object\n * @param {Options} options the options for the memoized function\n * @param {function} memoized the memoized function\n */\nexport const setPromiseHandler = (cache: Cache, options: Options, memoized: Function): void => {\n  const key: any = cache.keys[0];\n\n  cache.values[0] = cache.values[0]\n    .then((value: any): any => {\n      options.onCacheHit(cache, options, memoized);\n      options.onCacheChange(cache, options, memoized);\n\n      return value;\n    })\n    .catch((error: Error) => {\n      const keyIndex: number = createGetKeyIndex(options.isEqual)(cache.keys, key);\n\n      if (~keyIndex) {\n        cache.keys.splice(keyIndex, 1);\n        cache.values.splice(keyIndex, 1);\n      }\n\n      throw error;\n    });\n};\n","// @flow\n\n// types\nimport type {Cache, Options} from './types';\n\n// utils\nimport {\n  cloneArray,\n  createGetKeyIndex,\n  createGetTransformedKey,\n  isSameValueZero,\n  onCacheOperation,\n  orderByLru,\n  setPromiseHandler\n} from './utils';\n\n/**\n * @function memoize\n *\n * @description\n * get the memoized version of the method passed\n *\n * @param {function} fn the method to memoize\n * @param {Object} [options={}] the options to build the memoizer with\n * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with\n * @param {number} [options.maxSize=1] the number of items to store in cache\n * @returns {function} the memoized method\n */\nexport default function memoize(fn: Function, options: Options) {\n  // if it is a memoized method, don't re-memoize it\n  if (fn.isMemoized) {\n    return fn;\n  }\n\n  const {\n    isEqual = isSameValueZero,\n    isPromise = false,\n    maxSize = 1,\n    onCacheAdd = onCacheOperation,\n    onCacheChange = onCacheOperation,\n    onCacheHit = onCacheOperation,\n    transformKey,\n    ...extraOptions\n  } =\n    options || {};\n\n  const normalizedOptions = Object.assign({}, extraOptions, {\n    isEqual,\n    isPromise,\n    maxSize,\n    onCacheAdd,\n    onCacheChange,\n    onCacheHit,\n    transformKey\n  });\n\n  const getKeyIndex: Function = createGetKeyIndex(isEqual);\n  const getTransformedKey: ?Function = transformKey ? createGetTransformedKey(transformKey) : null;\n  const cache: Cache = {\n    keys: [],\n    values: []\n  };\n\n  const {keys, values} = cache;\n\n  /**\n   * @function memoized\n   *\n   * @description\n   * the memoized version of the method passed\n   *\n   * @param {...Array<any>} key the arguments passed, which create a unique cache key\n   * @returns {any} the value of the method called with the arguments\n   */\n  function memoized(): any {\n    const args: Array<any> | Object = getTransformedKey ? getTransformedKey(cloneArray(arguments)) : arguments;\n    const keyIndex: number = getKeyIndex(keys, args);\n\n    if (~keyIndex) {\n      onCacheHit(cache, normalizedOptions, memoized);\n\n      if (keyIndex) {\n        orderByLru(keys, keys[keyIndex], keyIndex);\n        orderByLru(values, values[keyIndex], keyIndex);\n\n        onCacheChange(cache, normalizedOptions, memoized);\n      }\n    } else {\n      if (keys.length >= maxSize) {\n        keys.pop();\n        values.pop();\n      }\n\n      orderByLru(keys, getTransformedKey ? args : cloneArray(args), keys.length);\n      orderByLru(values, fn.apply(this, arguments), values.length);\n\n      if (isPromise) {\n        setPromiseHandler(cache, normalizedOptions, memoized);\n      }\n\n      onCacheAdd(cache, normalizedOptions, memoized);\n      onCacheChange(cache, normalizedOptions, memoized);\n    }\n\n    return values[0];\n  }\n\n  Object.defineProperties(\n    memoized,\n    ({\n      cache: {\n        configurable: true,\n        get() {\n          return cache;\n        }\n      },\n      cacheSnapshot: {\n        configurable: true,\n        get() {\n          return {\n            keys: cloneArray(cache.keys),\n            values: cloneArray(cache.values)\n          };\n        }\n      },\n      isMemoized: {\n        configurable: true,\n        get() {\n          return true;\n        }\n      },\n      options: {\n        configurable: true,\n        get() {\n          return normalizedOptions;\n        }\n      }\n    }: Object)\n  );\n\n  return memoized;\n}\n"],"names":["cloneArray","arrayLike","array","Array","length","index","createAreKeysEqual","isEqual","keys1","keys2","createGetKeyIndex","areKeysEqual","allKeys","keysToMatch","createGetTransformedKey","transformKey","args","key","isArray","isSameValueZero","object1","object2","onCacheOperation","cacheIgnored","optionsIgnored","memoized","orderByLru","value","startingIndex","setPromiseHandler","cache","options","keys","values","then","onCacheHit","onCacheChange","catch","error","keyIndex","splice","memoize","fn","isMemoized","isPromise","maxSize","onCacheAdd","extraOptions","normalizedOptions","Object","assign","getKeyIndex","getTransformedKey","arguments","pop","apply","defineProperties"],"mappings":"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"}
'use strict';

exports.__esModule = true;
exports.default = memoize;

var _utils = require('./utils');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// utils


/**
 * @function memoize
 *
 * @description
 * get the memoized version of the method passed
 *
 * @param {function} fn the method to memoize
 * @param {Object} [options={}] the options to build the memoizer with
 * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with
 * @param {number} [options.maxSize=1] the number of items to store in cache
 * @returns {function} the memoized method
 */


// types
function memoize(fn, options) {
  // if it is a memoized method, don't re-memoize it
  if (fn.isMemoized) {
    return fn;
  }

  var _ref = options || {},
      _ref$isEqual = _ref.isEqual,
      isEqual = _ref$isEqual === undefined ? _utils.isSameValueZero : _ref$isEqual,
      _ref$isPromise = _ref.isPromise,
      isPromise = _ref$isPromise === undefined ? false : _ref$isPromise,
      _ref$maxSize = _ref.maxSize,
      maxSize = _ref$maxSize === undefined ? 1 : _ref$maxSize,
      _ref$onCacheAdd = _ref.onCacheAdd,
      onCacheAdd = _ref$onCacheAdd === undefined ? _utils.onCacheOperation : _ref$onCacheAdd,
      _ref$onCacheChange = _ref.onCacheChange,
      onCacheChange = _ref$onCacheChange === undefined ? _utils.onCacheOperation : _ref$onCacheChange,
      _ref$onCacheHit = _ref.onCacheHit,
      onCacheHit = _ref$onCacheHit === undefined ? _utils.onCacheOperation : _ref$onCacheHit,
      transformKey = _ref.transformKey,
      extraOptions = _objectWithoutProperties(_ref, ['isEqual', 'isPromise', 'maxSize', 'onCacheAdd', 'onCacheChange', 'onCacheHit', 'transformKey']);

  var normalizedOptions = Object.assign({}, extraOptions, {
    isEqual: isEqual,
    isPromise: isPromise,
    maxSize: maxSize,
    onCacheAdd: onCacheAdd,
    onCacheChange: onCacheChange,
    onCacheHit: onCacheHit,
    transformKey: transformKey
  });

  var getKeyIndex = (0, _utils.createGetKeyIndex)(isEqual);
  var getTransformedKey = transformKey ? (0, _utils.createGetTransformedKey)(transformKey) : null;
  var cache = {
    keys: [],
    values: []
  };

  var keys = cache.keys,
      values = cache.values;

  /**
   * @function memoized
   *
   * @description
   * the memoized version of the method passed
   *
   * @param {...Array<any>} key the arguments passed, which create a unique cache key
   * @returns {any} the value of the method called with the arguments
   */

  function memoized() {
    var args = getTransformedKey ? getTransformedKey((0, _utils.cloneArray)(arguments)) : arguments;
    var keyIndex = getKeyIndex(keys, args);

    if (~keyIndex) {
      onCacheHit(cache, normalizedOptions, memoized);

      if (keyIndex) {
        (0, _utils.orderByLru)(keys, keys[keyIndex], keyIndex);
        (0, _utils.orderByLru)(values, values[keyIndex], keyIndex);

        onCacheChange(cache, normalizedOptions, memoized);
      }
    } else {
      if (keys.length >= maxSize) {
        keys.pop();
        values.pop();
      }

      (0, _utils.orderByLru)(keys, getTransformedKey ? args : (0, _utils.cloneArray)(args), keys.length);
      (0, _utils.orderByLru)(values, fn.apply(this, arguments), values.length);

      if (isPromise) {
        (0, _utils.setPromiseHandler)(cache, normalizedOptions, memoized);
      }

      onCacheAdd(cache, normalizedOptions, memoized);
      onCacheChange(cache, normalizedOptions, memoized);
    }

    return values[0];
  }

  Object.defineProperties(memoized, {
    cache: {
      configurable: true,
      get: function get() {
        return cache;
      }
    },
    cacheSnapshot: {
      configurable: true,
      get: function get() {
        return {
          keys: (0, _utils.cloneArray)(cache.keys),
          values: (0, _utils.cloneArray)(cache.values)
        };
      }
    },
    isMemoized: {
      configurable: true,
      get: function get() {
        return true;
      }
    },
    options: {
      configurable: true,
      get: function get() {
        return normalizedOptions;
      }
    }
  });

  return memoized;
}
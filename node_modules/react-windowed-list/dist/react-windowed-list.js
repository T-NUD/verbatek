(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('remeasure')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'remeasure'], factory) :
  (factory((global.WindowedList = {}),global.React,global.ReactDOM,global.Remeasure));
}(this, (function (exports,React,reactDom,remeasure) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  // external dependencies

  /**
   * @constant {Object} IGNORED_COMPONENT_KEYS keys to ignore when creating a component
   */
  var IGNORED_COMPONENT_KEYS = {
    getInitialState: true,
    getInitialValues: true,
    isPure: true,
    onConstruct: true,
    state: true
  };

  /**
   * @constant {Object} IGNORED_STATIC_KEYS keys to ignore when assigning statics to a component
   */
  var IGNORED_STATIC_KEYS = {
    displayName: true
  };

  /**
   * @function bindSetState
   *
   * @description
   * bind the setState method to the component instance to ensure it can be used in a functional way
   *
   * @param {ReactComponent} instance the instance to bind setState to
   * @returns {void}
   */
  var bindSetState = function bindSetState(instance) {
    return Object.prototype.hasOwnProperty.call(instance.setState, 'prototype') ? instance.setState = instance.setState.bind(instance) : instance.setState;
  };

  /**
   * @function isClassComponent
   *
   * @description
   * is the value passed a valid react component class instance
   *
   * @param {any} value the value to test
   * @returns {boolean} is the value a react component instance
   */
  var isClassComponent = function isClassComponent(value) {
    return !!value && value instanceof React.Component;
  };

  /**
   * @function logInvalidInstanceError
   *
   * @description
   * notify the user that the instance passed is invalid
   *
   * @param {string} type the type of creator being called
   * @returns {void}
   */
  var logInvalidInstanceError = function logInvalidInstanceError(type) {
    return console.error('The instance provided for use with the ' + type + ' is not a valid React component instance.');
  }; // eslint-disable-line no-console

  /**
   * @function createRefCreator
   *
   * @description
   * create a method that will assign a ref value to the instance passed
   *
   * @param {function} getter the function that gets the component value for the ref
   * @returns {function(ReactComponent, string): function((HTMLElement|Component)): void} the ref create
   */
  var createRefCreator = function createRefCreator(getter) {
    return function (instance, ref) {
      return isClassComponent(instance) ? function (component) {
        return instance[ref] = getter(component);
      } : logInvalidInstanceError('ref');
    };
  };

  /**
   * @function identity
   *
   * @description
   * return the first parameter passed
   *
   * @param {any} value the value to pass through
   * @returns {any} the first parameter passed
   */
  var identity = function identity(value) {
    return value;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /**
   * @function createComponentRef
   *
   * @description
   * create a ref that assigns the component itself to the instance
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {ReactComponent} the component ref
   */
  var createComponentRef = createRefCreator(identity);

  /**
   * @function createMethod
   *
   * @description
   * create a method that is a pure version of the lifecycle / instance method passed to it
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} method the instance method
   * @param {Array<any>} extraArgs additional args to pass to the method
   * @returns {function(...Array<any>): any} the method with the instance passed as value
   */
  var createMethod = function createMethod(instance, method) {
    for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      extraArgs[_key - 2] = arguments[_key];
    }

    return isClassComponent(instance) ? bindSetState(instance) && function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return method.call(instance, instance, args, extraArgs);
    } : logInvalidInstanceError('method');
  };

  /**
   * @function createRender
   *
   * @description
   * create a method that is a pure version of the render method
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} render the render method
   * @returns {function(): ReactElement} the method with the props and instance passed as values
   */
  var createRender = function createRender(instance, render) {
    return isClassComponent(instance) ? bindSetState(instance) && function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return render.call(instance, instance.props, instance, args);
    } : logInvalidInstanceError('render');
  };

  /**
   * @function createRenderProps
   *
   * @description
   * create a render props method, where the props passed and the instance it is rendered in are passed as props to it
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} renderProps the render props method
   * @returns {function(Object): ReactElement} the method with the props and instance passed as values
   */
  var createRenderProps = function createRenderProps(instance, renderProps) {
    return isClassComponent(instance) ? bindSetState(instance) && function (props) {
      for (var _len4 = arguments.length, restOfArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        restOfArgs[_key4 - 1] = arguments[_key4];
      }

      return renderProps.call(instance, props, instance, restOfArgs);
    } : logInvalidInstanceError('render props');
  };

  /**
   * @function createValue
   *
   * @description
   * create a value to assign to the instance based on props or the instance itself
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} getValue the function to get the value with
   * @param {Array<any>} extraArgs additional args to pass to the method
   * @returns {function(...Array<any>): any} the method with the instance passed as value
   */
  var createValue = function createValue(instance, getValue) {
    for (var _len5 = arguments.length, extraArgs = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
      extraArgs[_key5 - 2] = arguments[_key5];
    }

    return isClassComponent(instance) ? bindSetState(instance) && getValue.call(instance, instance, extraArgs) : logInvalidInstanceError('value');
  };

  /**
   * @function createComponent
   *
   * @description
   * create a component from the render method and any options passed
   *
   * @param {function} render the function to render the component
   * @param {Object} [options={}] the options to render the component with
   * @param {function} [getInitialState] the method to get the initial state with
   * @param {boolean} [isPure] is PureComponent used
   * @param {function} [onConstruct] a method to call when constructing the component
   * @param {Object} [state] the initial state
   * @returns {ReactComponent} the component class
   */
  var createComponent = function createComponent(render, options) {
    var _ref = options || {},
        getInitialState = _ref.getInitialState,
        getInitialValues = _ref.getInitialValues,
        isPure = _ref.isPure,
        onConstruct = _ref.onConstruct,
        state = _ref.state;

    var Constructor = isPure ? React.PureComponent : React.Component;

    function ParmComponent(initialProps) {
      Constructor.call(this, initialProps);

      this.state = typeof getInitialState === 'function' ? createValue(this, getInitialState) : state || null;

      for (var key in options) {
        if (!IGNORED_COMPONENT_KEYS[key]) {
          this[key] = typeof options[key] === 'function' ? options[key].isRender ? createRender(this, options[key]) : options[key].isRenderProps ? createRenderProps(this, options[key]) : createMethod(this, options[key]) : options[key];
        }
      }

      var values = typeof getInitialValues === 'function' ? createValue(this, getInitialValues) : null;

      if (values && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
        for (var _key6 in values) {
          this[_key6] = values[_key6];
        }
      }

      this.render = createRender(this, render);

      if (typeof onConstruct === 'function') {
        onConstruct(this);
      }

      return this;
    }

    ParmComponent.prototype = Object.create(Constructor.prototype);

    ParmComponent.displayName = render.displayName || render.name || 'ParmComponent';

    Object.keys(render).forEach(function (staticKey) {
      return !IGNORED_STATIC_KEYS[staticKey] && (ParmComponent[staticKey] = render[staticKey]);
    });

    return ParmComponent;
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  var emptyFunction_1 = emptyFunction;

  var emptyFunction$1 = /*#__PURE__*/Object.freeze({
    default: emptyFunction_1,
    __moduleExports: emptyFunction_1
  });

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var validateFormat = function validateFormat(format) {};

  if (process.env.NODE_ENV !== 'production') {
    validateFormat = function validateFormat(format) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    };
  }

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  }

  var invariant_1 = invariant;

  var invariant$1 = /*#__PURE__*/Object.freeze({
    default: invariant_1,
    __moduleExports: invariant_1
  });

  var emptyFunction$2 = ( emptyFunction$1 && emptyFunction_1 ) || emptyFunction$1;

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var warning = emptyFunction$2;

  if (process.env.NODE_ENV !== 'production') {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  var warning_1 = warning;

  var warning$1 = /*#__PURE__*/Object.freeze({
    default: warning_1,
    __moduleExports: warning_1
  });

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols) {
  			symbols = getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  var objectAssign$1 = /*#__PURE__*/Object.freeze({
    default: objectAssign,
    __moduleExports: objectAssign
  });

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  var ReactPropTypesSecret$1 = /*#__PURE__*/Object.freeze({
    default: ReactPropTypesSecret_1,
    __moduleExports: ReactPropTypesSecret_1
  });

  var require$$0 = ( invariant$1 && invariant_1 ) || invariant$1;

  var require$$1 = ( warning$1 && warning_1 ) || warning$1;

  var require$$2 = ( ReactPropTypesSecret$1 && ReactPropTypesSecret_1 ) || ReactPropTypesSecret$1;

  if (process.env.NODE_ENV !== 'production') {
    var invariant$2 = require$$0;
    var warning$2 = require$$1;
    var ReactPropTypesSecret$2 = require$$2;
    var loggedTypeFailures = {};
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            invariant$2(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$2);
          } catch (ex) {
            error = ex;
          }
          warning$2(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;

            var stack = getStack ? getStack() : '';

            warning$2(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
          }
        }
      }
    }
  }

  var checkPropTypes_1 = checkPropTypes;

  var checkPropTypes$1 = /*#__PURE__*/Object.freeze({
    default: checkPropTypes_1,
    __moduleExports: checkPropTypes_1
  });

  var assign = ( objectAssign$1 && objectAssign ) || objectAssign$1;

  var checkPropTypes$2 = ( checkPropTypes$1 && checkPropTypes_1 ) || checkPropTypes$1;

  var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),

      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== require$$2) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            require$$0(
              false,
              'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
              'Use `PropTypes.checkPropTypes()` to call them. ' +
              'Read more at http://fb.me/use-check-prop-types'
            );
          } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (
              !manualPropTypeCallCache[cacheKey] &&
              // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3
            ) {
              require$$1(
                false,
                'You are manually calling a React.PropTypes validation ' +
                'function for the `%s` prop on `%s`. This is deprecated ' +
                'and will throw in the standalone `prop-types` package. ' +
                'You may be seeing this warning due to a third-party PropTypes ' +
                'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
                propFullName,
                componentName
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);

      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);

          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunction$2.thatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', require$$2);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        process.env.NODE_ENV !== 'production' ? require$$1(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
        return emptyFunction$2.thatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }
        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, require$$2);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== 'production' ? require$$1(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunction$2.thatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          require$$1(
            false,
            'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
            'received %s at index %s.',
            getPostfixForTypeWarning(checker),
            i
          );
          return emptyFunction$2.thatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (checker(props, propName, componentName, location, propFullName, require$$2) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, require$$2);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        // We need to check all keys in case some are required but missing from
        // props.
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (!checker) {
            return new PropTypeError(
              'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
              '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
              '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, require$$2);
          if (error) {
            return error;
          }
        }
        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;
        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes$2;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var factoryWithTypeCheckers$1 = /*#__PURE__*/Object.freeze({
    default: factoryWithTypeCheckers,
    __moduleExports: factoryWithTypeCheckers
  });

  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === require$$2) {
        // It is still safe when called from React.
        return;
      }
      require$$0(
        false,
        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
        'Use PropTypes.checkPropTypes() to call them. ' +
        'Read more at http://fb.me/use-check-prop-types'
      );
    }  shim.isRequired = shim;
    function getShim() {
      return shim;
    }  // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,

      any: shim,
      arrayOf: getShim,
      element: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim
    };

    ReactPropTypes.checkPropTypes = emptyFunction$2;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var factoryWithThrowingShims$1 = /*#__PURE__*/Object.freeze({
    default: factoryWithThrowingShims,
    __moduleExports: factoryWithThrowingShims
  });

  var require$$0$1 = ( factoryWithTypeCheckers$1 && factoryWithTypeCheckers ) || factoryWithTypeCheckers$1;

  var require$$1$1 = ( factoryWithThrowingShims$1 && factoryWithThrowingShims ) || factoryWithThrowingShims$1;

  var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  if (process.env.NODE_ENV !== 'production') {
    var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
      Symbol.for &&
      Symbol.for('react.element')) ||
      0xeac7;

    var isValidElement = function(object) {
      return typeof object === 'object' &&
        object !== null &&
        object.$$typeof === REACT_ELEMENT_TYPE;
    };

    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = require$$0$1(isValidElement, throwOnDirectAccess);
  } else {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = require$$1$1();
  }
  });

  // external dependencies

  /**
   * @constant {boolean} ADD_EVENT_LISTENER_OPTIONS
   * @default
   */
  var ADD_EVENT_LISTENER_OPTIONS = function () {
    if (typeof window === 'undefined') {
      return false;
    }

    var hasSupport = false;

    try {
      document.createElement('div').addEventListener('test', function () {}, {
        get passive() {
          hasSupport = true;

          return false;
        }
      });
      /* eslint-disable no-empty */
    } catch (e) {}
    /* eslint-enable */

    return hasSupport;
  }() ? {
    passive: true
  } : false;

  /**
   * @constant {Object} CLIENT_SIZE_KEYS
   */
  var CLIENT_SIZE_KEYS = {
    x: 'clientWidth',
    y: 'clientHeight'
  };

  /**
   * @constant {Object} CLIENT_START_KEYS
   */
  var CLIENT_START_KEYS = {
    x: 'clientTop',
    y: 'clientLeft'
  };

  /**
   * @constant {Object} INNER_SIZE_KEYS
   */
  var INNER_SIZE_KEYS = {
    x: 'innerWidth',
    y: 'innerHeight'
  };

  /**
   * @constant {Object} OFFSET_SIZE_KEYS
   */
  var OFFSET_SIZE_KEYS = {
    x: 'offsetWidth',
    y: 'offsetHeight'
  };

  /**
   * @constant {Object} OFFSET_START_KEYS
   */
  var OFFSET_START_KEYS = {
    x: 'offsetLeft',
    y: 'offsetTop'
  };

  /**
   * @constant {Object} OVERFLOW_KEYS
   */
  var OVERFLOW_KEYS = {
    x: 'overflowX',
    y: 'overflowY'
  };

  /**
   * @constant {Array<string>} OVERFLOW_VALUES
   */
  var OVERFLOW_VALUES = ['auto', 'scroll', 'overlay'];

  /**
   * @constant {Object} SCROLL_SIZE_KEYS
   */
  var SCROLL_SIZE_KEYS = {
    x: 'scrollWidth',
    y: 'scrollHeight'
  };

  /**
   * @constant {Object} SCROLL_START_KEYS
   */
  var SCROLL_START_KEYS = {
    x: 'scrollLeft',
    y: 'scrollTop'
  };

  /**
   * @constant {Object} SIZE_KEYS
   */
  var SIZE_KEYS = {
    x: 'width',
    y: 'height'
  };

  /**
   * @constant {string} UNSTABLE_MESSAGE
   * @default
   */
  var UNSTABLE_MESSAGE = 'WindowedList failed to reach a stable state.';

  /**
   * @constant {number} MAX_SYNC_UPDATES
   * @default
   */
  var MAX_SYNC_UPDATES = 100;

  /**
   * @constant {Object} VALID_AXES
   */
  var VALID_AXES = {
    X: 'x',
    Y: 'y'
  };

  /**
   * @constant {Array<string>} VALID_AXIS_VALUES
   */
  var VALID_AXIS_VALUES = Object.keys(VALID_AXES).map(function (key) {
    return VALID_AXES[key];
  });

  /**
   * @constant {Object} VALID_TYPES
   */
  var VALID_TYPES = {
    SIMPLE: 'simple',
    UNIFORM: 'uniform',
    VARIABLE: 'variable'
  };

  /**
   * @constant {Array<string>} VALID_TYPE_VALUES
   */
  var VALID_TYPE_VALUES = Object.keys(VALID_TYPES).map(function (key) {
    return VALID_TYPES[key];
  });

  /**
   * @constant {Object} OUTER_CONTAINER_STYLE
   */
  var OUTER_CONTAINER_STYLE = {
    height: '100%',
    maxHeight: 'inherit',
    width: '100%'
  };

  /**
   * @constant {Object} DEFAULT_CONTAINER_STYLE
   */
  var DEFAULT_CONTAINER_STYLE = {
    position: 'relative'
  };

  /**
   * @constant {number} UNSTABLE_TIMEOUT
   */
  var UNSTABLE_TIMEOUT = 250;

  /**
   * @constant {number} REACT_MINOR_VERSION
   */
  var REACT_MINOR_VERSION = +React.version.split('.').slice(0, 2).join('.');

  /**
   * @constant {boolean} HAS_NEW_LIFECYCLE_METHODS
   */
  var HAS_NEW_LIFECYCLE_METHODS = REACT_MINOR_VERSION >= 16.3;

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing. The function also has a property 'clear' 
   * that is a function which will clear the timer to prevent previously scheduled executions. 
   *
   * @source underscore.js
   * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
   * @param {Function} function to wrap
   * @param {Number} timeout in ms (`100`)
   * @param {Boolean} whether to execute at the beginning (`false`)
   * @api public
   */

  var debounce = function debounce(func, wait, immediate){
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;

    function later() {
      var last = Date.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    var debounced = function(){
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };

    debounced.clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    
    debounced.flush = function() {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        
        clearTimeout(timeout);
        timeout = null;
      }
    };

    return debounced;
  };

  var performanceNow = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(commonjsGlobal);


  });

  var performanceNow$1 = /*#__PURE__*/Object.freeze({
    default: performanceNow,
    __moduleExports: performanceNow
  });

  var now = ( performanceNow$1 && performanceNow ) || performanceNow$1;

  var root = typeof window === 'undefined' ? commonjsGlobal : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root['request' + suffix]
    , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for(var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix];
    caf = root[vendors[i] + 'Cancel' + suffix]
        || root[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = now()
          , next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn)
  };
  var cancel = function() {
    caf.apply(root, arguments);
  };
  var polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @function isFunction
   *
   * @description
   * is the object passed a function
   *
   * @param {*} object the object to test
   * @returns {boolean} is teh object a function
   */
  var isFunction = function isFunction(object) {
    return typeof object === 'function';
  };

  /**
   * @function isNAN
   *
   * @description
   * is the object passed a NaN
   *
   * @param {*} object the object to test
   * @returns {boolean} is teh object a NaN
   */
  var isNAN = function isNAN(object) {
    return object !== object;
  };

  /**
   * @function isNumber
   *
   * @description
   * is the object passed a number
   *
   * @param {*} object the object to test
   * @returns {boolean} is teh object a number
   */
  var isNumber = function isNumber(object) {
    return typeof object === 'number';
  };

  /**
   * @function noop
   *
   * @description
   * a no-op method
   */
  var noop = function noop() {};

  /**
   * @function areStateValuesEqual
   *
   * @description
   * should the state be updated based on the values of nextPossibleState being different
   *
   * @param {Object} currentState the current state of the instance
   * @param {Object} nextPossibleState the state to apply
   * @returns {boolean} should the state be updated
   */
  var areStateValuesEqual = function areStateValuesEqual(currentState, nextPossibleState) {
    for (var key in nextPossibleState) {
      if (currentState[key] !== nextPossibleState[key]) {
        return false;
      }
    }

    return true;
  };

  /**
   * @function coalesceToZero
   *
   * @description
   * return the value if truthy, else zero
   *
   * @param {*} value the value to compare
   * @returns {*} the value or zero
   */
  var coalesceToZero = function coalesceToZero(value) {
    return value || 0;
  };

  /**
   * @function DefaultItemRenderer
   *
   * @description
   * the default method to create the item element
   *
   * @param {number} index the index of the item in the list
   * @param {number} key the key to provide to the item
   * @returns {ReactElement} the generated element
   */
  var DefaultItemRenderer = function DefaultItemRenderer(index, key) {
    return React.createElement(
      'div',
      { key: key },
      index
    );
  };

  /**
   * @function DefaultContainerRenderer
   *
   * @description
   * the default method to create the list container
   *
   * @param {Array<ReactElement>} items the items to render in the list
   * @param {function} ref the ref to provide to the list container
   * @returns {ReactElement} the generated element
   */
  var DefaultContainerRenderer = function DefaultContainerRenderer(items, ref) {
    return React.createElement(
      'div',
      { ref: ref },
      items
    );
  };

  /**
   * @function getOffset
   *
   * @description
   * get the offset of the element based on its position and axis
   *
   * @param {HTMLElement} element the element to get the offset of
   * @param {string} axis the axis of the component
   * @returns {number} the element offset requested
   */
  var getOffset = function getOffset(element, axis) {
    var offsetKey = OFFSET_START_KEYS[axis];

    var offset = coalesceToZero(element[CLIENT_START_KEYS[axis]]) + coalesceToZero(element[offsetKey]);

    while (element = element.offsetParent) {
      offset += coalesceToZero(element[offsetKey]);
    }

    return offset;
  };

  /**
   * @function getCalculatedElementEnd
   *
   * @description
   * get the pixel size of the window based on the last element in the list of elements passed
   *
   * @param {Array<HTMLElement>} elements the elements displayed
   * @param {string} axis the axis of the component
   * @returns {number} the pixel size of the window
   */
  var getCalculatedElementEnd = function getCalculatedElementEnd(elements, _ref) {
    var axis = _ref.axis;

    if (!elements.length) {
      return 0;
    }

    var firstItemEl = elements[0];
    var lastItemEl = elements[elements.length - 1];

    return getOffset(lastItemEl, axis) + lastItemEl[OFFSET_SIZE_KEYS[axis]] - getOffset(firstItemEl, axis);
  };

  /**
   * @function getCalculatedSpaceBefore
   *
   * @description
   * get the space before the given length
   *
   * @param {Object} cache the cache of sizes in the instance
   * @param {number} length the length of items to get the space of
   * @param {function} getSizeOfListItem the method to get the size of the list item
   * @returns {number} the space before the given length
   */
  var getCalculatedSpaceBefore = function getCalculatedSpaceBefore(cache, length, getSizeOfListItem) {
    var from = length;

    while (from > 0 && !isNumber(cache[from])) {
      --from;
    }

    var space = coalesceToZero(cache[from]),
        itemSize = void 0;

    for (var index = from; index < length; index++) {
      cache[index] = space;
      itemSize = getSizeOfListItem(index);

      if (!isNumber(itemSize)) {
        break;
      }

      space += itemSize;
    }

    return space;
  };

  /**
   * @function getCalculatedItemSizeAndItemsPerRow
   *
   * @description
   * get the itemSize and itemsPerRow properties based on the elements passed
   *
   * @NOTE
   * Firefox has a problem where it will return a *slightly* (less than
   * thousandths of a pixel) different size for the same element between
   * renders. instance can cause an infinite render loop, so only change the
   * itemSize when it is significantly different.
   *
   * @param {Array<HTMLElement>} elements the elements to get the itemSize for
   * @param {string} axis the axis of the component
   * @param {number} currentItemSize the itemSize currently in state
   * @returns {{itemSize: number, itemsPerRow: number}} the new itemSize and itemsPerRow properties
   */
  var getCalculatedItemSizeAndItemsPerRow = function getCalculatedItemSizeAndItemsPerRow(elements, axis, currentItemSize) {
    var firstEl = elements[0];
    var firstElSize = firstEl[OFFSET_SIZE_KEYS[axis]];
    var delta = Math.abs(firstElSize - currentItemSize);

    var itemSize = isNAN(delta) || delta > 0 ? firstElSize : currentItemSize;

    if (!itemSize) {
      return {};
    }

    var startKey = OFFSET_START_KEYS[axis];
    var firstStart = firstEl[startKey];

    var itemsPerRow = 1,
        item = elements[itemsPerRow];

    while (item && item[startKey] === firstStart) {
      item = elements[++itemsPerRow];
    }

    return {
      itemSize: itemSize,
      itemsPerRow: itemsPerRow
    };
  };

  var getInnerContainerStyle = function getInnerContainerStyle(axis, length, itemsPerRow, getSize) {
    var _extends2, _extends3;

    var size = getSize(Math.ceil(length / itemsPerRow) * itemsPerRow, {});

    if (!size) {
      return DEFAULT_CONTAINER_STYLE;
    }

    var axisKey = SIZE_KEYS[axis];

    return axis !== VALID_AXES.X ? _extends({}, DEFAULT_CONTAINER_STYLE, (_extends2 = {}, _extends2[axisKey] = size, _extends2)) : _extends({}, DEFAULT_CONTAINER_STYLE, (_extends3 = {}, _extends3[axisKey] = size, _extends3.overflowX = 'hidden', _extends3));
  };

  /**
   * @function getFromAndSize
   *
   * @description
   * calculate the from and size values based on the number of items per row
   *
   * @param {number} currentFrom the current from in state
   * @param {number} currentSize the current size in state
   * @param {number} itemsPerRow the number of items per row in state
   * @param {boolean} isLazy is the list lazily loaded
   * @param {number} length the total number of items
   * @param {number} pageSize the size of batches to render
   * @param {string} type the type of list
   * @returns {{from: number, size: number}} the from and size propertioes
   */
  var getFromAndSize = function getFromAndSize(currentFrom, currentSize, itemsPerRow, _ref2) {
    var isLazy = _ref2.isLazy,
        length = _ref2.length,
        minSize = _ref2.minSize,
        pageSize = _ref2.pageSize,
        type = _ref2.type;

    var comparator = Math.max(minSize, isLazy && type === VALID_TYPES.UNIFORM ? 1 : pageSize);

    var size = Math.max(currentSize, comparator),
        mod = size % itemsPerRow;

    if (mod) {
      size += itemsPerRow - mod;
    }

    if (size > length) {
      size = length;
    }

    var from = !currentFrom || type === VALID_TYPES.SIMPLE ? 0 : Math.max(Math.min(currentFrom, length - size), 0);

    if (mod = from % itemsPerRow) {
      from -= mod;
      size += mod;
    }

    return {
      from: from,
      size: size
    };
  };

  /**
   * @function getFromAndSizeFromListItemSize
   *
   * @description
   * get the from and size properties based on the size of the list items
   *
   * @param {Object} startAndEnd the object with starting and ending indices of the displayed window
   * @param {number} startAndEnd.end the ending index of the items to display
   * @param {number} startAndEnd.start the starting index of the items to display
   * @param {Object} props the current props of the component
   * @param {number} props.length the total size of the list
   * @param {number} props.pageSize the side of the page to display
   * @param {function} getSizeOfListItem the method to get the size of the list item
   * @param {Object} currentState the current state's from and size
   * @returns {{from: number, size: number}} the from and size properties
   */
  var getFromAndSizeFromListItemSize = function getFromAndSizeFromListItemSize(_ref3, _ref4, getSizeOfListItem, currentState) {
    var end = _ref3.end,
        start = _ref3.start;
    var length = _ref4.length,
        pageSize = _ref4.pageSize;

    var maxFrom = length - 1;

    var space = 0,
        from = 0,
        size = -1,
        itemSize = void 0;

    for (; from < maxFrom; from++) {
      itemSize = getSizeOfListItem(from);

      if (!isNumber(itemSize) || space + itemSize > start) {
        /**
         * @NOTE
         * if an alternative key is used, it causes jitter when the first item is removed from the DOM,
         * so render the first item if the calculated from is 1
         */
        if (from === 1) {
          from = 0;
        }

        break;
      }

      space += itemSize;
    }

    var maxSize = length - from;

    while (++size < maxSize && space < end) {
      itemSize = getSizeOfListItem(from + size);

      if (!isNumber(itemSize)) {
        size = Math.min(size + pageSize, maxSize);

        break;
      }

      space += itemSize;
    }

    return space ? {
      from: from,
      size: size
    } : currentState;
  };

  /**
   * @function getListContainerStyle
   *
   * @description
   * get the style object to provide to the list container
   *
   * @param {string} axis the axis of the component
   * @param {string} usePosition should position be used instead of the transform
   * @param {string} useTranslate3d should translate3d be used for the transform
   * @param {number} firstIndex the first index being rendered
   * @param {function} getOffset the method to get the offset value
   * @returns {Object} the style object for the list container
   */
  var getListContainerStyle = function getListContainerStyle(axis, usePosition, useTranslate3d, firstIndex, getOffset) {
    var offset = getOffset(firstIndex, {});
    var x = axis === VALID_AXES.X ? offset : 0;
    var y = axis === VALID_AXES.Y ? offset : 0;

    if (usePosition) {
      return {
        left: x,
        position: 'relative',
        top: y
      };
    }

    var transform = useTranslate3d ? 'translate3d(' + x + 'px, ' + y + 'px, 0)' : 'translate(' + x + 'px, ' + y + 'px)';

    return {
      msTransform: transform,
      WebkitTransform: transform,
      transform: transform
    };
  };

  /**
   * @function getScrollSize
   *
   * @description
   * get the scroll size of the element
   *
   * @param {HTMLElement} element the element to get the scroll size of
   * @param {string} axis the axis of the component
   * @returns {number} the scroll size of the element
   */
  var getScrollSize = function getScrollSize(element, axis) {
    return element === window ? Math.max(document.body[SCROLL_SIZE_KEYS[axis]], document.documentElement[SCROLL_SIZE_KEYS[axis]]) : element[SCROLL_SIZE_KEYS[axis]];
  };

  /**
   * @function getViewportSize
   *
   * @description
   * get the viewport size of the element
   *
   * @param {HTMLElement} element the element to get the viewport size of
   * @param {string} axis the axis of the component
   * @returns {number} the viewport size of the element
   */
  var getViewportSize = function getViewportSize(element, axis) {
    return element ? element === window ? window[INNER_SIZE_KEYS[axis]] : element[CLIENT_SIZE_KEYS[axis]] : 0;
  };

  /**
   * @function hasDeterminateSize
   *
   * @description
   * does the element have a predetermined size calculator
   *
   * @param {string} type the type of the component
   * @param {function} [getItemSize] the function to calculate the item size
   * @returns {boolean} is the size automatically determined
   */
  var hasDeterminateSize = function hasDeterminateSize(type, getItemSize) {
    return type === VALID_TYPES.UNIFORM || isFunction(getItemSize);
  };

  /**
   * @function setCacheSizes
   *
   * @description
   * set the rendered sizes in cache on the instance
   *
   * @param {number} from the first index to set the cache of
   * @param {HTMLElement} element the list element
   * @param {string} axis the axis of the component
   * @param {Object} cache the cache to save to
   */
  var setCacheSizes = function setCacheSizes(from, element, axis, cache) {
    var itemElements = element.children;
    var sizeKey = OFFSET_SIZE_KEYS[axis];

    for (var index = 0; index < itemElements.length; index++) {
      cache[from + index] = itemElements[index][sizeKey];
    }
  };

  var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @function getItemSizeAndItemsPerRow
   *
   * @description
   * get the itemSize and itemsPerRow values based on props
   *
   * @param {Array<ReactElement>} items the items passed
   * @param {string} axis the axis being scrolled on
   * @param {boolean} useStaticSize should a static size be used
   * @param {number} itemSize the current size of the item in state
   * @param {number} itemsPerRow the current number of rows in state
   * @returns {Object} the itemSize and itemsPerRow
   */
  var getItemSizeAndItemsPerRow = function getItemSizeAndItemsPerRow(_ref) {
    var items = _ref.items,
        _ref$props = _ref.props,
        axis = _ref$props.axis,
        useStaticSize = _ref$props.useStaticSize,
        _ref$state = _ref.state,
        itemSize = _ref$state.itemSize,
        itemsPerRow = _ref$state.itemsPerRow;

    if (useStaticSize && itemSize && itemsPerRow) {
      return {
        itemSize: itemSize,
        itemsPerRow: itemsPerRow
      };
    }

    var itemElements = items ? items.children : [];

    return itemElements.length ? getCalculatedItemSizeAndItemsPerRow(itemElements, axis, itemSize) : {};
  };

  /**
   * @function getScrollOffset
   *
   * @description
   * get the scroll offset based on props
   *
   * @param {HTMLElement} outerContainer the outer container
   * @param {string} axis the axis being scrolled on
   * @param {HTMLElement} scrollParent the parent being scrolled
   * @returns {number} the scrollOffset to apply
   */
  var getScrollOffset = function getScrollOffset(_ref2) {
    var outerContainer = _ref2.outerContainer,
        axis = _ref2.props.axis,
        scrollParent = _ref2.scrollParent;

    if (!outerContainer || !scrollParent) {
      return 0;
    }

    var scrollKey = SCROLL_START_KEYS[axis];
    var actual = scrollParent === window ? document.body[scrollKey] || document.documentElement[scrollKey] : scrollParent[scrollKey];

    var max = getScrollSize(scrollParent, axis) - getViewportSize(scrollParent, axis);
    var scroll = Math.max(0, Math.min(actual, max));

    return getOffset(scrollParent, axis) + scroll - getOffset(outerContainer, axis);
  };

  /**
   * @function getScrollParent
   *
   * @description
   * get the scroll parent element
   *
   * @param {HTMLElement} outerContainer the outer container
   * @param {string} axis the axis being scrolled on
   * @param {function} getScrollParent the method to get the scrollParent
   * @returns {HTMLElement} the scroll parent
   */
  var getScrollParent = function getScrollParent(_ref3) {
    var outerContainer = _ref3.outerContainer,
        _ref3$props = _ref3.props,
        axis = _ref3$props.axis,
        getScrollParent = _ref3$props.getScrollParent;

    if (isFunction(getScrollParent)) {
      return getScrollParent();
    }

    if (!outerContainer) {
      return null;
    }

    var overflowKey = OVERFLOW_KEYS[axis];

    var element = outerContainer;

    while (element = element.parentElement) {
      if (~OVERFLOW_VALUES.indexOf(window.getComputedStyle(element)[overflowKey])) {
        return element;
      }
    }

    return window;
  };

  /**
   * @function getSizeOfListItem
   *
   * @description
   * get the size of the list item requested
   *
   * @param {Object} cache the current cache in state
   * @param {Array<ReactElement>} items the items rendered
   * @param {string} axis the axis being scrolled on
   * @param {function} getEstimatedItemSize the method used to estimate the item size
   * @param {function} getItemSize the method used to get the item size
   * @param {string} type the list type
   * @param {number} from the first index being rendered
   * @param {number} itemSize the size of each item
   * @param {number} size the number of items being rendered
   * @param {number} index the index of the list item
   * @returns {number} the size of the list item
   */
  var getSizeOfListItem = function getSizeOfListItem(_ref4, _ref5) {
    var cache = _ref4.cache,
        items = _ref4.items,
        _ref4$props = _ref4.props,
        axis = _ref4$props.axis,
        getEstimatedItemSize = _ref4$props.getEstimatedItemSize,
        getItemSize = _ref4$props.getItemSize,
        type = _ref4$props.type,
        _ref4$state = _ref4.state,
        from = _ref4$state.from,
        itemSize = _ref4$state.itemSize,
        size = _ref4$state.size;
    var index = _ref5[0];

    // Try the static itemSize.
    if (itemSize) {
      return itemSize;
    }

    // Try the getItemSize.
    if (isFunction(getItemSize)) {
      return getItemSize(index);
    }

    // Try the cache.
    if (isNumber(cache[index])) {
      return cache[index];
    }

    if (items) {
      var itemElements = items.children;

      // Try the DOM.
      if (itemElements.length && type === VALID_TYPES.SIMPLE && index >= from && index < from + size) {
        var itemEl = itemElements[index - from];

        if (itemEl) {
          return itemEl[OFFSET_SIZE_KEYS[axis]];
        }
      }
    }

    // Try the getEstimatedItemSize.
    if (isFunction(getEstimatedItemSize)) {
      return getEstimatedItemSize(index, cache);
    }
  };

  /**
   * @function getSpaceBefore
   *
   * @description
   * get the space before the item requested
   *
   * @param {function} getSizeOfListItem method to get the size of the item
   * @param {number} itemSize the size of each item
   * @param {number} itemsPerRow the number of items per row
   * @param {number} index the index of the item requested
   * @param {Object} [cache={}] the instance cache
   * @returns {number} the space before the item requested
   */
  var getSpaceBefore = function getSpaceBefore(_ref6, _ref7) {
    var getSizeOfListItem = _ref6.getSizeOfListItem,
        _ref6$state = _ref6.state,
        itemSize = _ref6$state.itemSize,
        itemsPerRow = _ref6$state.itemsPerRow;
    var index = _ref7[0],
        _ref7$ = _ref7[1],
        cache = _ref7$ === undefined ? {} : _ref7$;

    if (isNumber(cache[index])) {
      return cache[index];
    }

    cache[index] = itemSize ? Math.floor(index / itemsPerRow) * itemSize : getCalculatedSpaceBefore(cache, index, getSizeOfListItem);

    return cache[index];
  };

  /**
   * @function getStartAndEnd
   *
   * @description
   * get the start and end values based on scroll position
   *
   * @param {function} getScrollOffset the method to get the scroll offset
   * @param {function} getSpaceBefore the method to get the space before the first rendered item
   * @param {string} axis the scroll axis
   * @param {function} getItemSize the method used to get the item size
   * @param {number} length the number of total items
   * @param {number} defaultThreshold the threshold value
   * @param {string} type the type of renderer used
   * @param {number} [threshold=defaultThreshold] the pixel threshold to scroll above and below
   * @returns {{end: number, start: number}} the start and end of the window
   */
  var getStartAndEnd = function getStartAndEnd(_ref8, _ref9) {
    var getScrollOffset = _ref8.getScrollOffset,
        getSpaceBefore = _ref8.getSpaceBefore,
        _ref8$props = _ref8.props,
        axis = _ref8$props.axis,
        getItemSize = _ref8$props.getItemSize,
        length = _ref8$props.length,
        defaultThreshold = _ref8$props.threshold,
        type = _ref8$props.type,
        scrollParent = _ref8.scrollParent;
    var _ref9$ = _ref9[0],
        threshold = _ref9$ === undefined ? defaultThreshold : _ref9$;

    var scroll = getScrollOffset();
    var calculatedEnd = scroll + getViewportSize(scrollParent, axis) + threshold;

    return {
      end: hasDeterminateSize(type, getItemSize) ? Math.min(calculatedEnd, getSpaceBefore(length)) : calculatedEnd,
      start: Math.max(0, scroll - threshold)
    };
  };

  /**
   * @function getVisibleRange
   *
   * @description
   * get the indices of the first and last items that are visible in the viewport
   *
   * @returns {Array<number>} the first and last index of the visible items
   */
  var getVisibleRange = function getVisibleRange(_ref10) {
    var getSizeOfListItem = _ref10.getSizeOfListItem,
        getSpaceBefore = _ref10.getSpaceBefore,
        getStartAndEnd = _ref10.getStartAndEnd,
        _ref10$state = _ref10.state,
        from = _ref10$state.from,
        size = _ref10$state.size;

    var _getStartAndEnd = getStartAndEnd(0),
        end = _getStartAndEnd.end,
        start = _getStartAndEnd.start;

    var cache = {};
    var length = from + size;

    var first = void 0,
        last = void 0,
        itemStart = void 0,
        itemEnd = void 0;

    for (var index = from; index < length; index++) {
      itemStart = getSpaceBefore(index, cache);
      itemEnd = itemStart + getSizeOfListItem(index);

      if (!isNumber(first)) {
        if (itemEnd > start) {
          first = index;
        }
      } else if (itemStart < end) {
        last = index;
      }
    }

    return [first, last];
  };

  /**
   * @function renderItems
   *
   * @description
   * render the items that are currently visible
   *
   * @param {ReactComponent} instance the component instance
   * @returns {ReactElement} the rendered container with the items
   */
  var renderItems = function renderItems(instance) {
    var _instance$props = instance.props,
        itemRenderer = _instance$props.itemRenderer,
        containerRenderer = _instance$props.containerRenderer,
        _instance$state = instance.state,
        from = _instance$state.from,
        size = _instance$state.size;


    var items = new Array(size);

    for (var index = 0; index < size; index++) {
      items[index] = itemRenderer(from + index, index);
    }

    return containerRenderer(items, function (containerRef) {
      return instance.items = reactDom.findDOMNode(containerRef);
    });
  };

  /**
   * @function scrollAround
   *
   * @description
   * scroll to a point that the item is within the window, but not necessarily at the top
   *
   * @param {number} index the index to scroll to in the window
   * @returns {void}
   */
  var scrollAround = function scrollAround(_ref11, _ref12) {
    var getScrollOffset = _ref11.getScrollOffset,
        getSizeOfListItem = _ref11.getSizeOfListItem,
        getSpaceBefore = _ref11.getSpaceBefore,
        getViewportSize$$1 = _ref11.getViewportSize,
        setScroll = _ref11.setScroll;
    var index = _ref12[0];

    var bottom = getSpaceBefore(index);
    var top = bottom - getViewportSize$$1() + getSizeOfListItem(index);

    var min = Math.min(top, bottom);
    var current = getScrollOffset();

    if (current <= min) {
      return setScroll(min);
    }

    var max = Math.max(top, bottom);

    if (current > max) {
      return setScroll(max);
    }
  };

  /**
   * @function scrollTo
   *
   * @description
   * scroll the element to the requested initialIndex
   *
   * @param {number} index the index to scroll to
   */
  var scrollTo = function scrollTo(_ref13, _ref14) {
    var getSpaceBefore = _ref13.getSpaceBefore,
        initialIndex = _ref13.props.initialIndex,
        setScroll = _ref13.setScroll;
    var index = _ref14[0];

    var indexToScrollTo = isNumber(index) ? index : initialIndex;

    if (isNumber(indexToScrollTo)) {
      setScroll(getSpaceBefore(indexToScrollTo));
    }
  };

  /**
   * @function setReconcileFrameAfterUpdate
   *
   * @description
   * set the frame reconciler used after componentDidUpdate
   *
   * @param {ReactComponent} instance the component instance
   */
  var setReconcileFrameAfterUpdate = function setReconcileFrameAfterUpdate(instance) {
    var debounceReconciler = instance.props.debounceReconciler;


    instance.reconcileFrameAfterUpdate = isNumber(debounceReconciler) ? debounce(function (updateFrame) {
      updateFrame();
    }, debounceReconciler) : raf_1;
  };

  /**
   * @function setScroll
   *
   * @description
   * set the scroll based on the current offset
   *
   * @param {number} currentOffset the current offset
   * @returns {void}
   */
  var setScroll = function setScroll(_ref15, _ref16) {
    var outerContainer = _ref15.outerContainer,
        axis = _ref15.props.axis,
        scrollParent = _ref15.scrollParent;
    var currentOffset = _ref16[0];

    if (!scrollParent || !outerContainer) {
      return;
    }

    var offset = currentOffset + getOffset(outerContainer, axis);

    if (scrollParent === window) {
      return window.scrollTo(0, offset);
    }

    scrollParent[SCROLL_START_KEYS[axis]] = offset - getOffset(scrollParent, axis);
  };

  /**
   * @function setStateIfAppropriate
   *
   * @description
   * set the state if areStateValuesEqual returns true
   *
   * @param {Object} nextState the possible next state of the instance
   * @param {function} callback the callback to call once the state is set
   * @returns {void}
   */
  var setStateIfAppropriate = function setStateIfAppropriate(_ref17, _ref18) {
    var setState = _ref17.setState,
        state = _ref17.state;
    var nextState = _ref18[0],
        callback = _ref18[1];
    return areStateValuesEqual(state, nextState) ? callback() : setState(nextState, callback);
  };

  /**
   * @function updateFrame
   *
   * @description
   * update the frame based on the type in props
   *
   * @param {function} callback the function to call once the frame is updated
   * @returns {void}
   */
  var updateFrame = function updateFrame(_ref19, _ref20) {
    var type = _ref19.props.type,
        updateScrollParent = _ref19.updateScrollParent,
        updateSimpleFrame = _ref19.updateSimpleFrame,
        updateUniformFrame = _ref19.updateUniformFrame,
        updateVariableFrame = _ref19.updateVariableFrame;
    var callback = _ref20[0];

    updateScrollParent();

    var updateCallback = isFunction(callback) ? callback : noop;

    return type === VALID_TYPES.UNIFORM ? updateUniformFrame(updateCallback) : type === VALID_TYPES.VARIABLE ? updateVariableFrame(updateCallback) : updateSimpleFrame(updateCallback);
  };

  /**
   * @function updateScrollParent
   *
   * @description
   * update the scroll parent with the listeners it needs
   *
   * @param {ReactComponent} instance the component instance
   * @returns {void}
   */
  var updateScrollParent = function updateScrollParent(instance) {
    var getScrollParent = instance.getScrollParent,
        scrollParent = instance.scrollParent,
        updateFrame = instance.updateFrame;


    var newScrollParent = getScrollParent();

    if (newScrollParent === scrollParent) {
      return;
    }

    if (scrollParent) {
      scrollParent.removeEventListener('scroll', updateFrame);
      scrollParent.removeEventListener('mousewheel', noop);
    }

    instance.scrollParent = newScrollParent;

    if (newScrollParent) {
      newScrollParent.addEventListener('scroll', updateFrame, ADD_EVENT_LISTENER_OPTIONS);
      newScrollParent.addEventListener('mousewheel', noop, ADD_EVENT_LISTENER_OPTIONS);
    }
  };

  /**
   * @function updateSimpleFrame
   *
   * @description
   * update the frame when the type is 'simple'
   *
   * @param {function} callback the function to call once the frame is updated
   * @returns {void}
   */
  var updateSimpleFrame = function updateSimpleFrame(_ref21, _ref22) {
    var getStartAndEnd = _ref21.getStartAndEnd,
        items = _ref21.items,
        props = _ref21.props,
        setStateIfAppropriate = _ref21.setStateIfAppropriate,
        size = _ref21.state.size;
    var callback = _ref22[0];
    return items && getCalculatedElementEnd(items.children, props) <= getStartAndEnd().end ? setStateIfAppropriate({
      size: Math.min(size + props.pageSize, props.length)
    }, callback) : callback();
  };

  /**
   * @function updateUniformFrame
   *
   * @description
   * update the frame when the type is 'uniform'
   *
   * @param {function} callback the function to call once the frame is updated
   * @returns {void}
   */
  var updateUniformFrame = function updateUniformFrame(_ref23, _ref24) {
    var getItemSizeAndItemsPerRow = _ref23.getItemSizeAndItemsPerRow,
        getStartAndEnd = _ref23.getStartAndEnd,
        props = _ref23.props,
        setStateIfAppropriate = _ref23.setStateIfAppropriate;
    var callback = _ref24[0];

    var _getItemSizeAndItemsP = getItemSizeAndItemsPerRow(),
        itemSize = _getItemSizeAndItemsP.itemSize,
        itemsPerRow = _getItemSizeAndItemsP.itemsPerRow;

    if (!itemSize || !itemsPerRow) {
      return callback();
    }

    var _getStartAndEnd2 = getStartAndEnd(),
        start = _getStartAndEnd2.start,
        end = _getStartAndEnd2.end;

    var calculatedFrom = Math.floor(start / itemSize) * itemsPerRow;
    var calulatedSize = (Math.ceil((end - start) / itemSize) + 1) * itemsPerRow;
    var fromAndSize = getFromAndSize(calculatedFrom, calulatedSize, itemsPerRow, props);

    return setStateIfAppropriate(_extends$1({}, fromAndSize, {
      itemSize: itemSize,
      itemsPerRow: itemsPerRow
    }), callback);
  };

  /**
   * @function updateVariableFrame
   *
   * @description
   * update the frame when the type is 'variable'
   *
   * @param {function} callback the function to call once the frame is updated
   * @returns {void}
   */
  var updateVariableFrame = function updateVariableFrame(_ref25, _ref26) {
    var cache = _ref25.cache,
        items = _ref25.items,
        getSizeOfListItem = _ref25.getSizeOfListItem,
        getStartAndEnd = _ref25.getStartAndEnd,
        props = _ref25.props,
        setStateIfAppropriate = _ref25.setStateIfAppropriate,
        _ref25$state = _ref25.state,
        currentFrom = _ref25$state.from,
        currentSize = _ref25$state.size;
    var callback = _ref26[0];

    if (!items) {
      return;
    }

    if (!props.getItemSize) {
      setCacheSizes(currentFrom, items, props.axis, cache);
    }

    setStateIfAppropriate(getFromAndSizeFromListItemSize(getStartAndEnd(), props, getSizeOfListItem, {
      from: currentFrom,
      size: currentSize
    }), callback);
  };

  var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @function onConstruct
   *
   * @description
   * on construction, set the initial state
   *
   * @param {ReactComponent} instance the component instance
   */
  var onConstruct = function onConstruct(instance) {
    var props = instance.props,
        setReconcileFrameAfterUpdate = instance.setReconcileFrameAfterUpdate,
        state = instance.state;


    var itemsPerRow = 1;

    setReconcileFrameAfterUpdate();

    instance.state = _extends$2({}, state, getFromAndSize(props.initialIndex, 0, itemsPerRow, props), {
      itemsPerRow: itemsPerRow
    });
  };

  /**
   * @function componentDidMount
   *
   * @description
   * on mount, update the frame with the desired scroll position
   *
   * @param {ReactComponent} instance the component instance
   */
  var componentDidMount = function componentDidMount(instance) {
    instance.outerContainer = reactDom.findDOMNode(instance);

    if (!instance.props.isHidden) {
      raf_1(function () {
        return instance.updateFrame(instance.scrollTo);
      });
    }
  };

  /**
   * @function getDerivedStateFromProps
   *
   * @description
   * get the next state based on the next props
   *
   * @param {Object} nextProps the next props passed
   * @param {number} from the first index to render
   * @param {number} itemsPerRow the number of items per row
   * @param {number} size the number of items to render
   * @returns {Object|null} the next state, if applicable
   */
  var getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var from = _ref.from,
        itemsPerRow = _ref.itemsPerRow,
        size = _ref.size;

    var fromAndSize = getFromAndSize(from, size, itemsPerRow, nextProps);

    return fromAndSize.from === from && fromAndSize.size === size ? null : fromAndSize;
  };

  /**
   * @function componentWillReceiveProps
   *
   * @description
   * when props are received, set the state if the next calculated state is different
   *
   * @param {number} debounceReconciler the debounce reconciler in props
   * @param {function} setReconcileFrameAfterUpdate the method to set the reconciler frame
   * @param {function} setStateIfAppropriate the method to set the state if changed
   * @param {number} from the first index to render
   * @param {number} itemsPerRow the number of items per row
   * @param {number} size the number of items to render
   * @param {Object} nextProps the incoming props
   */
  var componentWillReceiveProps = function componentWillReceiveProps(_ref2, _ref3) {
    var debounceReconciler = _ref2.props.debounceReconciler,
        setReconcileFrameAfterUpdate = _ref2.setReconcileFrameAfterUpdate,
        setStateIfAppropriate = _ref2.setStateIfAppropriate,
        _ref2$state = _ref2.state,
        from = _ref2$state.from,
        itemsPerRow = _ref2$state.itemsPerRow,
        size = _ref2$state.size;
    var nextProps = _ref3[0];

    if (debounceReconciler !== nextProps.debounceReconciler) {
      setReconcileFrameAfterUpdate();
    }

    setStateIfAppropriate(getFromAndSize(from, size, itemsPerRow, nextProps), noop);
  };

  /**
   * @function getSnapshotBeforeUpdate
   *
   * @description
   * update the debounce reconciler if the values have changed in props
   *
   * @param {number} debounceReconciler the delay to wait before reconciling in props
   * @param {function} setReconcileFrameAfterUpdate the method to set the reconciler frame
   * @param {Object} previousProps the previous props values
   * @returns {void}
   */
  var getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(_ref4, _ref5) {
    var debounceReconciler = _ref4.props.debounceReconciler,
        setReconcileFrameAfterUpdate = _ref4.setReconcileFrameAfterUpdate;
    var previousProps = _ref5[0];
    return debounceReconciler !== previousProps.debounceReconciler && setReconcileFrameAfterUpdate();
  };

  /**
   * @function componentDidUpdate
   *
   * @description
   * update the frame position, cutting off after a certain point if unstable
   *
   * @param {ReactComponent} instance the component instance
   * @returns {void}
   */
  var componentDidUpdate = function componentDidUpdate(instance) {
    if (instance.unstableTimeoutId || ++instance.updateCounter > MAX_SYNC_UPDATES) {
      clearTimeout(instance.unstableTimeoutId);

      if (!instance.unstableTimeoutId) {
        console.error(UNSTABLE_MESSAGE); // eslint-disable-line no-console
      }

      instance.unstableTimeoutId = setTimeout(function () {
        instance.unstableTimeoutId = null;
        instance.updateCounter = 0;
      }, UNSTABLE_TIMEOUT);

      return;
    }

    if (!instance.updateCounterTimeoutId) {
      instance.updateCounterTimeoutId = raf_1(function () {
        instance.updateCounter = 0;
        instance.updateCounterTimeoutId = null;
      });
    }

    if (!instance.props.isHidden) {
      instance.reconcileFrameAfterUpdate(instance.updateFrame);
    }
  };

  /**
   * @function componentWillUnmount
   *
   * @description
   * before unmount, remove any listeners applied to the scroll container
   *
   * @param {ReactComponent} instance the component instance
   */
  var componentWillUnmount = function componentWillUnmount(instance) {
    if (instance.scrollParent) {
      instance.scrollParent.removeEventListener('scroll', instance.updateFrame, ADD_EVENT_LISTENER_OPTIONS);
      instance.scrollParent.removeEventListener('mousewheel', noop, ADD_EVENT_LISTENER_OPTIONS);
    }

    instance.outerContainer = null;
  };

  var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var DEFAULT_PARM_OPTIONS = {
    // state
    state: {
      from: 0,
      itemsPerRow: 0,
      size: 0
    },
    // lifecycle methods
    onConstruct: onConstruct,
    componentDidMount: componentDidMount,
    componentDidUpdate: componentDidUpdate,
    componentWillUnmount: componentWillUnmount,
    // instance values
    cache: {},
    outerContainer: null,
    reconcileFrameAfterUpdate: null,
    unstableTimeoutId: null,
    updateCounter: 0,
    updateCounterTimeoutId: null,
    // instance methods
    getItemSizeAndItemsPerRow: getItemSizeAndItemsPerRow,
    getScrollOffset: getScrollOffset,
    getScrollParent: getScrollParent,
    getSizeOfListItem: getSizeOfListItem,
    getSpaceBefore: getSpaceBefore,
    getStartAndEnd: getStartAndEnd,
    getVisibleRange: getVisibleRange,
    renderItems: renderItems,
    scrollAround: scrollAround,
    scrollTo: scrollTo,
    setReconcileFrameAfterUpdate: setReconcileFrameAfterUpdate,
    setScroll: setScroll,
    setStateIfAppropriate: setStateIfAppropriate,
    updateFrame: updateFrame,
    updateScrollParent: updateScrollParent,
    updateSimpleFrame: updateSimpleFrame,
    updateUniformFrame: updateUniformFrame,
    updateVariableFrame: updateVariableFrame
  };

  var PARM_OPTIONS = HAS_NEW_LIFECYCLE_METHODS ? _extends$3({}, DEFAULT_PARM_OPTIONS, {
    getSnapshotBeforeUpdate: getSnapshotBeforeUpdate
  }) : _extends$3({}, DEFAULT_PARM_OPTIONS, {
    componentWillReceiveProps: componentWillReceiveProps
  });

  var WindowedListRenderer = createComponent(function (_ref, _ref2) {
    var axis = _ref.axis,
        length = _ref.length,
        type = _ref.type,
        usePosition = _ref.usePosition,
        useTranslate3d = _ref.useTranslate3d;
    var getSpaceBefore$$1 = _ref2.getSpaceBefore,
        renderItems$$1 = _ref2.renderItems,
        _ref2$state = _ref2.state,
        from = _ref2$state.from,
        itemsPerRow = _ref2$state.itemsPerRow;
    return type === VALID_TYPES.SIMPLE ? renderItems$$1() : React.createElement(
      'div',
      { style: OUTER_CONTAINER_STYLE },
      React.createElement(
        'div',
        { style: getInnerContainerStyle(axis, length, itemsPerRow, getSpaceBefore$$1) },
        React.createElement(
          'div',
          { style: getListContainerStyle(axis, usePosition, useTranslate3d, from, getSpaceBefore$$1) },
          renderItems$$1()
        )
      )
    );
  }, PARM_OPTIONS);

  WindowedListRenderer.displayName = 'WindowedListRenderer';

  WindowedListRenderer.propTypes = {
    axis: propTypes.oneOf(VALID_AXIS_VALUES).isRequired,
    containerRenderer: propTypes.func.isRequired,
    debounceReconciler: propTypes.number,
    getEstimatedItemSize: propTypes.func,
    getItemSize: propTypes.func,
    getScrollParent: propTypes.func,
    initialIndex: propTypes.number.isRequired,
    isHidden: propTypes.bool.isRequired,
    isLazy: propTypes.bool.isRequired,
    itemRenderer: propTypes.func.isRequired,
    length: propTypes.number.isRequired,
    pageSize: propTypes.number.isRequired,
    threshold: propTypes.number.isRequired,
    type: propTypes.oneOf(VALID_TYPE_VALUES).isRequired,
    usePosition: propTypes.bool.isRequired,
    useStaticSize: propTypes.bool.isRequired,
    useTranslate3d: propTypes.bool.isRequired
  };

  WindowedListRenderer.defaultProps = {
    axis: VALID_AXES.Y,
    containerRenderer: DefaultContainerRenderer,
    initialIndex: 0,
    isHidden: false,
    isLazy: false,
    itemRenderer: DefaultItemRenderer,
    length: 0,
    minSize: 1,
    pageSize: 10,
    threshold: 100,
    type: VALID_TYPES.SIMPLE,
    usePosition: false,
    useStaticSize: false,
    useTranslate3d: false
  };

  if (HAS_NEW_LIFECYCLE_METHODS) {
    WindowedListRenderer.getDerivedStateFromProps = getDerivedStateFromProps;
  }

  var WindowedListRenderer$1 = remeasure.measure(['height', 'width'], { namespace: '__windowedListMeasurements' })(WindowedListRenderer);

  var _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @function getVisibleRange
   *
   * @description
   * get the visible range on the windowed list component
   *
   * @param {ReactComponent} ref the WindowedList component
   * @returns {Array<number>}
   */
  var getVisibleRange$1 = function getVisibleRange(_ref) {
    var ref = _ref.ref;
    return ref && ref.originalComponent ? ref.originalComponent.getVisibleRange() : [0, 0];
  };

  /**
   * @function scrollAround
   *
   * @description
   * scroll around the index passed on the windowed list component
   *
   * @param {ReactComponent} ref the WindowedList component
   * @param {number} index the index to scroll around
   * @returns {Array<number>}
   */
  var scrollAround$1 = function scrollAround(_ref2, _ref3) {
    var ref = _ref2.ref;
    var index = _ref3[0];
    return ref && ref.originalComponent ? ref.originalComponent.scrollAround(index) : null;
  };

  /**
   * @function scrollTo
   *
   * @description
   * scroll to the index passed on the windowed list component
   *
   * @param {ReactComponent} ref the WindowedList component
   * @param {number} index the index to scroll to
   * @returns {Array<number>}
   */
  var scrollTo$1 = function scrollTo(_ref4, _ref5) {
    var ref = _ref4.ref;
    var index = _ref5[0];
    return ref && ref.originalComponent ? ref.originalComponent.scrollTo(index) : null;
  };

  var WindowedList = function WindowedList(props, instance) {
    return (
      /* eslint-disable prettier */
      React.createElement(WindowedListRenderer$1, _extends$4({}, props, {
        ref: createComponentRef(instance, 'ref')
      }))
      /* eslint-enable */

    );
  };

  WindowedList.displayName = 'WindowedList';

  var WindowedList$1 = createComponent(WindowedList, {
    // instance values
    ref: null,
    // instance methods
    getVisibleRange: getVisibleRange$1,
    scrollAround: scrollAround$1,
    scrollTo: scrollTo$1
  });

  // components

  exports.default = WindowedList$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-windowed-list.js.map
